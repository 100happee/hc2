happee
100happee
✝️ commit yourself to jesus. save yourselves now

👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 8/15/2025 12:35 AM
Bro's school is 3 weeks early lol
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 8/15/2025 3:17 AM
:toilet~1:
Muni — 8/15/2025 4:59 PM
I end May 17
And I get more than 6 1 week breaks
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 8/15/2025 5:04 PM
Bruh
Muni — 8/15/2025 5:05 PM
Nvm just 4 1 week breaks including winter
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 8/15/2025 6:48 PM
Muni — 8/15/2025 11:01 PM
Dakota was the most modern school I've been to  my school is so old
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 8/16/2025 2:15 AM
Muni — 8/16/2025 7:04 AM
Wait so now that school about to start for you are you going to quit your job
coolbroxz — 8/16/2025 12:06 PM
maybe because it was made 3 years ago
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 8/16/2025 12:37 PM
It's part time so I can just do 5-7s on weekdays and 11-7s on weekends
I'm coming home from Hawaii today and tomorrow
I'll arrive at 5 am lol
Muni — 8/16/2025 4:36 PM
Your right
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 8/16/2025 7:58 PM
Getting on 8 hour flight to home in 30 mins
Muni — Yesterday at 12:46 AM
15 hour flights  are the hardest
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 7:00 AM
Bro I just got home lolll
I'm actually pretty awake
Time to take a long nap bro
Muni — Yesterday at 9:18 AM
Nice
But seriously does anyone know who QUHA is on roblox
coolbroxz — Yesterday at 9:43 AM
iiiiiiiidik
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 8:55 PM
@everyone a look at happeechat2 rn but files and dms dont work rn ill fix it tmrw due to chatgpt5 limit
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HappeeChat2</title>
Expand
happee_chat_2_single_file_html_firebase_rtdb_storage.html
31 KB
coolbroxz — Yesterday at 8:55 PM
omg remeber happee chat
and remebmer in health when benet got so angry
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 8:56 PM
yes
coolbroxz — Yesterday at 8:56 PM
broo why doid you get so mad
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 8:56 PM
working ragebait method
coolbroxz — Yesterday at 8:56 PM
why did you8 grt dso nmad
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 8:57 PM
🙂  👍
coolbroxz — Yesterday at 8:57 PM
bro u know i swa that video too
nice try unc
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 8:57 PM
coolbroxz — Yesterday at 8:58 PM
:good:
:tuffness:
@👑skyler's ᴋɪɴɢ👑 Why are you so ancient
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 8:59 PM
coolbroxz — Yesterday at 8:59 PM
bro u R born in 2010 UNC
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 9:00 PM
2022 but i had a gen z childhood
coolbroxz — Yesterday at 9:00 PM
Shutttttt UPpppppppppp
imJoking
HaveaGrateDay! 😹
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 9:01 PM
https://www.youtube.com/shorts/VQqdNP7g5iA?feature=share
YouTube
Caldruki
like Pot of Greed 😭🙏 #memes #dankememes #funny #slideshow #sh...
Image
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — Yesterday at 11:32 PM
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 1:25 AM
files and dms work now just a few issues i need to fix
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HappeeChat2</title>
Expand
hc2 latest working build.html
13 KB
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 1:29 AM
@Metal Bacon download this and view it lol
Metal Bacon — 1:30 AM
:happysteam_2:
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 1:31 AM
when you create an acc you have to login on the left btw
do it for the test
👑skyler's ᴋɪɴɢ👑
[BEEP]
 — 2:52 PM
chat 5 is mid
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HappeeChat2</title>
Expand
hc2 last working.html
41 KB
this version works but its very janky
coolbroxz — 2:52 PM
Really!
﻿
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HappeeChat2</title>
<link rel="icon" href="https://i1.sndcdn.com/avatars-V22Gw2FsnsI9xMuU-ihNrRA-t240x240.jpg" />
<!-- Poppins font -->
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0e12;
    --panel:#0f1419;
    --muted:#8b97a6;
    --accent:#4da3ff;
    --contrast:#12161a;
    --bubble:#0e1317;
    --mention:#f5d35b;
    --mention-text:#1a1a1a;
    --max-width:1200px;
    font-family: 'Poppins', sans-serif;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071017 0%, #04060a 100%);color:#e6eef6}
  .app {
    max-width:var(--max-width);
    margin:18px auto;
    height:88vh;
    display:flex;
    gap:12px;
    border-radius:12px;
    overflow:hidden;
    box-shadow:0 10px 30px rgba(0,0,0,0.6);
  }
  /* Left column (contacts) */
  .left {
    width:88px;
    background:var(--panel);
    padding:12px 8px;
    display:flex;
    flex-direction:column;
    gap:8px;
    box-sizing:border-box;
  }
  .left .channel {
    display:flex;
    flex-direction:column;
    gap:8px;
    align-items:center;
  }
  .icon-btn {
    width:64px;height:64px;border-radius:10px;display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
    border:1px solid rgba(255,255,255,0.03);
    cursor:pointer;position:relative;overflow:hidden;
  }
  .icon-btn .badge {position:absolute;right:6px;top:6px;background:#ff6b6b;color:white;padding:2px 6px;border-radius:6px;font-size:11px}
  .icon-btn img, .icon-btn .hash {width:42px;height:42px;border-radius:8px;object-fit:cover}
  .icon-btn .hash {font-weight:700;color:var(--accent);font-size:34px}
  .bottom-left {margin-top:auto;display:flex;flex-direction:column;gap:8px;align-items:center}
  /* Middle column (users list) */
  .middle {
    width:260px;
    background:var(--panel);
    padding:12px;
    display:flex;
    flex-direction:column;
    gap:8px;
    box-sizing:border-box;
  }
  .search {display:flex;gap:6px}
  .search input{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
  .chat-list {overflow:auto;flex:1;padding-top:6px}
  .chat-item {display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;cursor:pointer}
  .chat-item:hover{background:rgba(255,255,255,0.02)}
  .chat-item img {width:44px;height:44px;border-radius:8px;object-fit:cover}
  .chat-item .meta {display:flex;flex-direction:column}
  .chat-item .meta .name {font-weight:600}
  .unread-count {margin-left:auto;background:#2b6aab;padding:4px 6px;border-radius:6px;font-size:12px}
  /* Right column (messages) */
  .right {
    flex:1;
    background:linear-gradient(180deg,var(--contrast),#081017);
    display:flex;flex-direction:column;padding:12px;box-sizing:border-box;
  }
  .header {
    display:flex;align-items:center;gap:12px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.02);
  }
  .header .title {font-size:18px;font-weight:700}
  .header .controls {margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn {background:var(--accent);color:#06121a;padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
  .btn.ghost{background:transparent;color:var(--accent);border:1px solid rgba(255,255,255,0.04)}
  .read-btn{background:#334153;color:white;padding:6px 8px;border-radius:8px}
  .volume {display:flex;align-items:center;gap:8px}
  .volume input[type=range]{width:120px}
  .messages {flex:1;overflow:auto;padding:12px;display:flex;flex-direction:column;gap:12px}
  .message {display:flex;gap:12px;align-items:flex-start;padding:8px;border-radius:8px;background:transparent;transition:background 120ms}
  .message:hover{background:rgba(255,255,255,0.01)}
  .message .avatar {width:48px;height:48px;border-radius:8px;object-fit:cover}
  .message .body {flex:1}
  .message .meta {display:flex;gap:8px;align-items:center}
  .message .username{font-weight:700}
  .message .text{margin-top:6px;white-space:pre-wrap}
  .message .timestamp{font-size:11px;color:var(--muted);margin-left:auto}
  .mention {background:var(--mention);color:var(--mention-text);padding:2px 6px;border-radius:6px}
  .atlink {color:var(--accent);font-weight:700}
  .file-embed {margin-top:8px;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);padding:6px;background: #070a0c}
  .input-row {display:flex;gap:8px;align-items:center;padding-top:8px;border-top:1px solid rgba(255,255,255,0.02)}
  .input-row textarea{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit;min-height:44px;max-height:120px;resize:none}
  .input-row .add-btn{width:44px;height:44px;border-radius:8px;border:1px dashed rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:pointer}
  .small {font-size:12px;color:var(--muted)}
  .login-overlay{position:absolute;inset:0;background:linear-gradient(180deg, rgba(3,6,9,0.6), rgba(3,6,9,0.9));display:flex;align-items:center;justify-content:center;z-index:9999}
  .login-box{width:760px;background:linear-gradient(180deg,#07101a,#081218);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:12px;box-sizing:border-box}
  .login-left{width:320px;padding:8px;display:flex;flex-direction:column;gap:8px}
  .account {display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;cursor:pointer}
  .account img{width:48px;height:48px;border-radius:8px;object-fit:cover}
  .create-form{flex:1;padding:8px;display:flex;flex-direction:column;gap:8px}
  input,button,select,textarea{font-family:inherit}
  .danger{background:#ff6b6b;color:white}
  .admin-delete {margin-left:auto;background:#7b2634;color:#fff;padding:6px;border-radius:8px;border:none;cursor:pointer}
  .dm-header{display:flex;align-items:center;gap:12px;padding:8px;border-radius:6px}
  .dm-header .title{font-weight:700}
  .no-messages {text-align:center;color:var(--muted);margin-top:24px}
  /* highlight for mention */
  .mentioned {background:linear-gradient(90deg,#3b2b03,#5a4710);border-radius:8px}
  /* small adjustments for responsiveness */
  @media(max-width:900px){
    .middle{display:none}
    .left{width:64px}
    .login-box{width:94%}
  }
</style>
</head>
<body>
<div style="position:relative">
  <div class="app" id="app">
    <div class="left">
      <div class="channel">
        <div title="Public Chat" id="btn-public" class="icon-btn" data-id="public">
          <div class="hash">#</div>
          <div class="badge" id="badge-public" style="display:none">0</div>
        </div>
        <div id="users-icons" style="display:flex;flex-direction:column;gap:8px"></div>
      </div>
      <div class="bottom-left">
        <div title="Create New" id="btn-new" class="icon-btn">+</div>
        <div title="Settings / Logout" id="btn-settings" class="icon-btn">⚙</div>
      </div>
    </div>

    <div class="middle">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <div style="font-weight:700">Chats</div>
        <div class="small" id="online-count">0 online</div>
      </div>
      <div class="search">
        <input id="search" placeholder="Search users..." />
        <button id="refresh-list" class="btn ghost">Refresh</button>
      </div>
      <div class="chat-list" id="chat-list"></div>
    </div>

    <div class="right">
      <div class="header">
        <div class="title" id="chat-title">Public Chat</div>
        <div class="controls">
          <div class="small">Ping vol</div>
          <div class="volume">
            <input id="volume-slider" type="range" min="0" max="100" value="70"/>
          </div>
          <button id="read-messages" class="read-btn small">Read Messages</button>
          <button id="logout" class="btn ghost small">Logout</button>
        </div>
      </div>

      <div id="dm-header-area"></div>

      <div class="messages" id="messages"></div>

      <div class="input-row">
        <label class="add-btn" title="Attach file" id="attach-btn">+</label>
        <input type="file" id="file-input" style="display:none" />
        <textarea id="txt-message" placeholder="Write a message..."></textarea>
        <button id="send-btn" class="btn">Send Message</button>
      </div>
    </div>
  </div>

  <!-- Login / Create account overlay -->
  <div class="login-overlay" id="login-overlay">
    <div class="login-box">
      <div class="login-left">
        <div style="font-size:18px;font-weight:800">Welcome to HappeeChat2</div>
        <div class="small">Choose an account or create a new one</div>
        <div id="accounts-list" style="margin-top:12px;overflow:auto"></div>
      </div>
      <div class="create-form">
        <div style="display:flex;gap:8px;align-items:center">
          <div style="font-weight:700">Create new account</div>
          <div class="small" style="margin-left:auto">Admin username: <code>100happee</code></div>
        </div>
        <input id="new-username" placeholder="username (unique)" />
        <input id="new-password" type="password" placeholder="password" />
        <div style="display:flex;gap:8px;align-items:center">
          <input id="avatar-file" type="file" accept="image/*" />
          <div id="avatar-preview" style="width:48px;height:48px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center">avatar</div>
        </div>
        <div style="display:flex;gap:8px">
          <button id="create-account" class="btn">Create account</button>
          <button id="refresh-accounts" class="btn ghost">Refresh</button>
        </div>
        <div id="login-msg" class="small" style="margin-top:8px;color:var(--muted)"></div>
      </div>
    </div>
  </div>
</div>

<!-- ping sound -->
<audio id="ping-audio" src="./ping.mp3" preload="auto"></audio>

<!-- Firebase SDK (modular) -->
<script type="module">
/* ============================
   HappeeChat2 — Single-file app
   ============================
   - Uses Firebase Realtime Database (modular SDK)
   - Files/avatars are stored as base64 (danger for huge scale — acceptable per spec).
   - Passwords are hashed client-side before storing (SHA-256).
   - Auto-cleanup runs when clients are active (7-day message deletion, 30-day idle users).
   - Admin is username '100happee' (cannot be deleted).
   - Blacklist words configured below in the variable `BLACKLIST`.
   - Message limit in public chat: 500 most recent messages.
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
import { getDatabase, ref, onValue, set, push, remove, get, child, update, query, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

/* -----------------------
   Firebase config (you provided)
   -----------------------*/
const firebaseConfig = {
  apiKey: "AIzaSyDkpDlINFiUzR0PsFRcxxk-N2fhHLnpACI",
  authDomain: "hchat2-1d004.firebaseapp.com",
  databaseURL: "https://hchat2-1d004-default-rtdb.firebaseio.com",
  projectId: "hchat2-1d004",
  storageBucket: "hchat2-1d004.firebasestorage.app",
  messagingSenderId: "807685526215",
  appId: "1:807685526215:web:6b9042099ff0b464be24e2"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ===============================
   CONFIG / variables you can edit
   =============================== */
/* Blacklist: words will be replaced with **** (case-insensitive substring match).
   Edit this array to add/remove words. */
const BLACKLIST = ["badword","anotherbadword"]; // <<--- edit here

/* Message retention rules (in ms) */
const MESSAGE_TTL = 7 * 24 * 60 * 60 * 1000; // 7 days
const IDLE_USER_TTL = 30 * 24 * 60 * 60 * 1000; // 30 days

/* Public chat limit */
const PUBLIC_CHAT_LIMIT = 500;

/* Admin username */
const ADMIN_USERNAME = "100happee";

/* ------------------------------
   Utilities
   ------------------------------*/
function el(sel){return document.querySelector(sel)}
function q(sel){return document.querySelectorAll(sel)}
function uid(){ // small unique id
  return 'id_' + Math.random().toString(36).slice(2,9);
}
function formatTimestamp(ts){
  const d = new Date(ts);
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  let hh = d.getHours(); const ampm = hh>=12? 'p' : 'a';
  hh = hh % 12; if(hh===0) hh=12;
  const min = String(d.getMinutes()).padStart(2,'0');
  return `${mm}/${dd} at ${hh}:${min}${ampm}`;
}
async function sha256hex(str){
  const enc = new TextEncoder();
  const data = enc.encode(str);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
}
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

/* ================================
   App state
   ================================*/
let state = {
  me: null,          // {username, avatarBase64, id, lastActive}
  selectedChat: 'public', // 'public' or 'dm:userid'
  usersCache: {},    // userId -> {username, avatar, lastActive}
  unread: {},        // chatId -> count
  messagesCache: {}, // chatId -> [messages]
  pingVolume: 0.7
};

/* ================
   DOM refs
   ================*/
const loginOverlay = el('#login-overlay');
const accountsList = el('#accounts-list');
const createBtn = el('#create-account');
const refreshAccounts = el('#refresh-accounts');
const avatarFile = el('#avatar-file');
const avatarPreview = el('#avatar-preview');
const newUsername = el('#new-username');
const newPassword = el('#new-password');
const loginMsg = el('#login-msg');

const btnPublic = el('#btn-public');
const usersIcons = el('#users-icons');
const chatList = el('#chat-list');
const messagesArea = el('#messages');
const chatTitle = el('#chat-title');
const txtMessage = el('#txt-message');
const sendBtn = el('#send-btn');
const fileInput = el('#file-input');
const attachBtn = el('#attach-btn');
const readMessagesBtn = el('#read-messages');
const volumeSlider = el('#volume-slider');
const pingAudio = el('#ping-audio');
const logoutBtn = el('#logout');
const refreshListBtn = el('#refresh-list');
const onlineCount = el('#online-count');
const badgePublic = el('#badge-public');

/* -------------------------
   Firebase paths helpers
   -------------------------*/
const dbRef = (p)=> ref(db, p);

/* ============================
   Core: users & accounts
   ============================*/

async function fetchUsersAndRender(){
  // Load users list
  onValue(dbRef('users'), snapshot => {
    const users = snapshot.val() || {};
    state.usersCache = users;
    renderAccountsList();
    renderUserIcons();
    renderChatList();
    updateOnlineCount();
  });
}

function renderAccountsList(){
  accountsList.innerHTML = '';
  const users = state.usersCache;
  const entries = Object.entries(users).sort((a,b)=> (b[1].lastActive||0)-(a[1].lastActive||0));
  for(const [id, u] of entries){
    if(u.deleted) continue;
    const div = document.createElement('div');
    div.className = 'account';
    div.dataset.userid = id;
    div.innerHTML = `<img src="${u.avatar||defaultAvatar(u.username)}" />
      <div style="display:flex;flex-direction:column">
        <div style="font-weight:700">${u.username}</div>
        <div class="small">${u.lastActive?('active '+timeAgo(u.lastActive)): 'never active'}</div>
      </div>`;
    div.onclick = ()=> promptLogin(id, u.username);
    accountsList.appendChild(div);
  }
}

function defaultAvatar(name){
  // simple gradient placeholder
  const letter = (name||'?').charAt(0).toUpperCase();
  return `https://via.placeholder.com/80/222229/ffffff?text=${encodeURIComponent(letter)}`;
}

function renderUserIcons(){
  usersIcons.innerHTML = '';
  const users = state.usersCache;
  const entries = Object.entries(users).filter(([id,u])=> !u.deleted);
  entries.sort((a,b)=> (a[1].username || '').localeCompare(b[1].username));
  for(const [id,u] of entries){
    const div = document.createElement('div');
    const img = document.createElement('img');
    img.src = u.avatar || defaultAvatar(u.username);
    img.style.width='56px'; img.style.height='56px'; img.style.borderRadius='8px';
    const btn = document.createElement('div');
    btn.className = 'icon-btn';
    btn.style.width='64px'; btn.style.height='64px';
    btn.appendChild(img);
    btn.onclick = ()=> openDMWith(id);
    usersIcons.appendChild(btn);
  }
}

function renderChatList(){
  chatList.innerHTML = '';
  // first public chat
  const pubEl = document.createElement('div');
  pubEl.className = 'chat-item';
  pubEl.dataset.chat = 'public';
  pubEl.innerHTML = `<div style="width:44px;height:44px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:800;color:var(--accent);background:transparent">#</div>
    <div class="meta"><div class="name">Public Chat</div><div class="small">Main public room</div></div>
    <div class="unread" style="margin-left:auto">${state.unread.public?('<div class="unread-count">'+state.unread.public+'</div>') : ''}</div>`;
  pubEl.onclick = ()=> selectChat('public');
  chatList.appendChild(pubEl);

  // then each user DM
  const users = state.usersCache;
  const entries = Object.entries(users).filter(([id,u])=> !u.deleted);
  entries.sort((a,b)=> (a[1].username||'').localeCompare(b[1].username));
  for(const [id,u] of entries){
    const elc = document.createElement('div');
    elc.className = 'chat-item';
    elc.dataset.chat = 'dm:'+id;
    elc.innerHTML = `<img src="${u.avatar||defaultAvatar(u.username)}" />
      <div class="meta"><div class="name">${u.username}</div><div class="small">Direct message</div></div>
      ${state.unread['dm:'+id]?('<div class="unread-count">'+state.unread['dm:'+id]+'</div>') : ''}`;
    elc.onclick = ()=> selectChat('dm:'+id);
    chatList.appendChild(elc);
  }
}

function updateOnlineCount(){
  const users = state.usersCache;
  const online = Object.values(users).filter(u=>!u.deleted && (Date.now() - (u.lastActive||0) < 5*60*1000)).length;
  onlineCount.textContent = `${online} online`;
}

/* =================================
   Login / create account flows
   =================================*/
let avatarBase64ForCreate = null;
avatarFile.addEventListener('change', async (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  if(f.size > 4*1024*1024){ alert('Avatar exceeds 4MB'); return; }
  const b = await fileToBase64(f);
  avatarBase64ForCreate = b;
  avatarPreview.innerHTML = `<img src="${b}" style="width:48px;height:48px;border-radius:8px;object-fit:cover" />`;
});

function openLoginOverlay(){
  loginOverlay.style.display = 'flex';
  newUsername.value = '';
  newPassword.value = '';
  avatarBase64ForCreate = null;
  avatarPreview.innerHTML = 'avatar';
}

refreshAccounts.addEventListener('click', ()=> { fetchUsersAndRender(); });

createBtn.addEventListener('click', async ()=>{
  const username = (newUsername.value||'').trim();
  const password = newPassword.value||'';
  if(!username || !password){ loginMsg.textContent = 'Enter username and password.'; return; }
  // disallow duplicate username (unique check)
  const usersSnap = await get(dbRef('users'));
  const users = usersSnap.val() || {};
  for(const [id,u] of Object.entries(users)){
    if(u.username && u.username.toLowerCase() === username.toLowerCase()){
      loginMsg.textContent = 'Username already exists.';
      return;
    }
  }
  // create a userid
  const id = uid();
  const hashed = await sha256hex(password);
  const userObj = {
    username,
    avatar: avatarBase64ForCreate || defaultAvatar(username),
    createdAt: Date.now(),
    lastActive: Date.now(),
    pwHash: hashed,
    deleted: false
  };
  await set(dbRef(`users/${id}`), userObj);
  loginMsg.textContent = 'Account created. Click your account to login.';
  // refresh userslist
  fetchUsersAndRender();
});

function promptLogin(userId, username){
  // show a modal prompt for password (simple prompt for now)
  const pw = prompt(`Enter password for ${username}`);
  if(pw === null) return;
  attemptLogin(userId, pw);
}

async function attemptLogin(userId, pw){
  const snap = await get(dbRef(`users/${userId}`));
  const u = snap.val();
  if(!u || u.deleted){ alert('Account not found'); return; }
  const h = await sha256hex(pw);
  if(h !== u.pwHash){ alert('Incorrect password'); return; }
  // login success
  state.me = { id: userId, username: u.username, avatar: u.avatar, lastActive: Date.now() };
  // update lastActive in DB
  await update(dbRef(`users/${userId}`), { lastActive: Date.now() });
  loginOverlay.style.display = 'none';
  // init listeners etc.
  afterLogin();
}

/* ============================
   Messages listening & sending
   ============================*/
function listenMessages(){
  // public chat
  onValue(dbRef('messages/public'), snapshot => {
    const obj = snapshot.val() || {};
    const msgs = Object.entries(obj).map(([id,m])=>({id,...m}));
    msgs.sort((a,b)=> (a.ts||0)-(b.ts||0));
    state.messagesCache['public'] = msgs;
    renderMessagesForCurrentChat();
    // update public unread count if not selected
    if(state.selectedChat !== 'public'){
      state.unread.public = (state.unread.public||0) + msgs.length - (state._lastSeen && state._lastSeen['public']? state._lastSeen['public'] : 0);
      updateUnreadBadges();
    }
    enforcePublicLimit();
  });

  // DMs: listen to /messages/dms and keep local filtered views. Simpler: listen to all DMs root and filter locally.
  onValue(dbRef('messages/dms'), snapshot => {
    const obj = snapshot.val() || {};
    // structure: dmid -> { messages: { mid: {...} } }
    const map = {};
    for(const [dmid, room] of Object.entries(obj)){
      const messagesObj = room.messages || {};
      const msgs = Object.entries(messagesObj).map(([id,m])=>({id,...m}));
      msgs.sort((a,b)=> (a.ts||0)-(b.ts||0));
      map[dmid] = msgs;
    }
    state.messagesCache['dms'] = map;
    renderMessagesForCurrentChat();
  });
}

async function enforcePublicLimit(){
  const msgs = state.messagesCache['public'] || [];
  if(msgs.length > PUBLIC_CHAT_LIMIT){
    // remove oldest messages
    const toRemove = msgs.slice(0, msgs.length - PUBLIC_CHAT_LIMIT);
    for(const m of toRemove){
      await remove(dbRef(`messages/public/${m.id}`));
    }
  }
}

async function sendMessage({to='public', text='', file=null, isDMWith=null}){
  if(!state.me) { alert('Please login'); openLoginOverlay(); return; }
  if(text.trim()==='' && !file){ return; }
  // apply blacklist (replace substrings with asterisks)
  const censored = censorText(text);
  const message = {
    fromId: state.me.id,
    fromUsername: state.me.username,
    avatar: state.me.avatar,
    text: censored,
    ts: Date.now(),
  };
  if(file) message.file = file;

  if(to === 'public'){
    const newRef = push(dbRef('messages/public'));
    await set(newRef, message);
    // play ping
    playPing();
  } else if(to.startsWith('dm:')){
    const otherId = to.split(':')[1];
    // create dmid as sorted pair
    const dmid = dmId(state.me.id, otherId);
    // store under messages/dms/{dmid}/messages/{pushid}
    const newRef = push(dbRef(`messages/dms/${dmid}/messages`));
    await set(newRef, message);
    playPing();
  }
  // update my lastActive
  await update(dbRef(`users/${state.me.id}`), { lastActive: Date.now() });
}

function dmId(a,b){ return [a,b].sort().join('__'); }

function playPing(){
  pingAudio.volume = state.pingVolume;
  pingAudio.currentTime = 0;
  pingAudio.play().catch(()=>{});
}

/* Render messages for whichever chat is selected */
function renderMessagesForCurrentChat(){
  const sel = state.selectedChat;
  messagesArea.innerHTML = '';
  if(sel === 'public'){
    const msgs = state.messagesCache['public'] || [];
    if(msgs.length === 0){
      messagesArea.innerHTML = `<div class="no-messages">No messages yet in public chat.</div>`;
      return;
    }
    for(const m of msgs){
      const el = messageToElement(m, 'public');
      messagesArea.appendChild(el);
    }
  } else if(sel.startsWith('dm:')){
    const other = sel.split(':')[1];
    const dmid = dmId(state.me.id, other);
    const msgs = (state.messagesCache['dms'] && state.messagesCache['dms'][dmid]) || [];
    if(msgs.length === 0){
      messagesArea.innerHTML = `<div class="no-messages">No messages yet in this DM.</div>`;
      return;
    }
    for(const m of msgs){
      const el = messageToElement(m, dmid);
      messagesArea.appendChild(el);
    }
    // DM header with delete user button if admin
    renderDMHeader(other);
  }
  // scroll to bottom
  messagesArea.scrollTop = messagesArea.scrollHeight;
}

function renderDMHeader(otherId){
  const u = state.usersCache[otherId] || { username: 'Unknown', avatar: defaultAvatar('U') };
  const area = el('#dm-header-area');
  area.innerHTML = `<div class="dm-header" style="border-bottom:1px solid rgba(255,255,255,0.02);padding-bottom:8px">
    <img src="${u.avatar}" style="width:44px;height:44px;border-radius:8px;object-fit:cover" />
    <div style="display:flex;flex-direction:column">
      <div class="title">${u.username}</div>
      <div class="small">Direct message</div>
    </div>
    <div style="margin-left:auto;display:flex;gap:8px">
      ${state.me && state.me.username === ADMIN_USERNAME ? `<button id="delete-user-btn" class="admin-delete">Delete User</button>` : ''}
    </div>
  </div>`;
  const delBtn = el('#delete-user-btn');
  if(delBtn){
    delBtn.onclick = ()=> deleteUserAndMessages(otherId);
  }
}

function messageToElement(m, chatId){
  const wrapper = document.createElement('div');
  wrapper.className = 'message';
  // highlight if contains @mention of me
  let highlightClass = '';
  if(state.me && m.text && m.text.toLowerCase().includes('@'+state.me.username.toLowerCase())){
    highlightClass = 'mentioned';
  }
  wrapper.innerHTML = `
    <img class="avatar" src="${m.avatar || defaultAvatar(m.fromUsername)}" />
    <div class="body ${highlightClass}">
      <div class="meta">
        <div class="username">${escapeHtml(m.fromUsername)}</div>
        <div class="timestamp">${formatTimestamp(m.ts)}</div>
      </div>
      <div class="text">${formatTextWithLinksAndMentions(m.text)}</div>
      ${m.file ? renderFileEmbedHtml(m.file) : ''}
    </div>
  `;
  // if admin show delete button on hover
  if(state.me && state.me.username === ADMIN_USERNAME){
    const del = document.createElement('button');
    del.className = 'admin-delete';
    del.textContent = 'Delete';
    del.style.marginLeft = '8px';
    del.style.height = '32px'; del.style.alignSelf='flex-start';
    del.onclick = async (ev)=>{
      ev.stopPropagation();
      if(confirm('Delete this message?')) {
        // remove message from whichever path it exists in
        // find in public
        const pub = state.messagesCache['public']||[];
        if(pub.find(x=>x.id===m.id)){
          await remove(dbRef(`messages/public/${m.id}`));
        } else {
          // might be in some dmid collection; search dms
          const dms = state.messagesCache['dms']||{};
          for(const [dmid, msgs] of Object.entries(dms)){
            if(msgs.find(x=>x.id===m.id)){
              await remove(dbRef(`messages/dms/${dmid}/messages/${m.id}`));
            }
          }
        }
      }
    };
    wrapper.querySelector('.body').prepend(del); // put near top
  }
  return wrapper;
}

function renderFileEmbedHtml(file){
  // file: {name, type, data (base64)}
  const type = file.type || '';
  const name = escapeHtml(file.name || 'file');
  const data = file.data;
  let html = `<div class="file-embed">`;
  if(type.startsWith('image/')){
    html += `<img src="${data}" style="max-width:540px;border-radius:8px;display:block" /><div><a download="${name}" href="${data}">Download</a></div>`;
  } else if(type.startsWith('video/')){
    html += `<video controls style="max-width:540px;display:block"><source src="${data}" type="${type}">Your browser doesn't support video</video><div><a download="${name}" href="${data}">Download</a></div>`;
  } else if(type.startsWith('audio/')){
    html += `<audio controls><source src="${data}" type="${type}">Your browser doesn't support audio</audio><div><a download="${name}" href="${data}">Download</a></div>`;
  } else {
    html += `<div>${name} <a download="${name}" href="${data}">Download</a></div>`;
  }
  html += `</div>`;
  return html;
}

/* -----------------------------
   Text formatting: links, mentions, youtube embed
   ----------------------------- */
function escapeHtml(str=''){ return String(str).replace(/[&<>"']/g, (m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

function formatTextWithLinksAndMentions(text=''){
  if(!text) return '';
  // find youtube links and replace with embed block then text contains will be cleaned
  // but for now we will just convert links to <a> and @username to link spans
  let out = escapeHtml(text);
  // embed youtube if present (simple regex)
  const ytRegex = /(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([A-Za-z0-9_\-]+))/ig;
  out = out.replace(ytRegex, (m, full, id)=>{
    const iframe = `<div style="margin-top:8px"><iframe width="420" height="236" src="https://www.youtube.com/embed/${id}" frameborder="0" allowfullscreen></iframe></div>`;
    return iframe;
  });
  // links
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  out = out.replace(urlRegex, (m)=>`<a href="${m}" target="_blank" style="color:var(--accent)">${escapeHtml(m)}</a>`);
  // mentions
  out = out.replace(/@([a-zA-Z0-9\-_]+)/g, (m, uname)=>`<span class="atlink">@${escapeHtml(uname)}</span>`);
  return out;
}

/* -----------------------------
   Unread management + title badge
   ----------------------------- */
function updateUnreadBadges(){
  // left icon badge
  if(state.unread.public && state.unread.public > 0){
    badgePublic.style.display = 'block';
    badgePublic.textContent = state.unread.public;
    document.title = `[${state.unread.public}] HappeeChat2`;
  } else {
    badgePublic.style.display = 'none';
    document.title = `HappeeChat2`;
  }
  // chat list badges
  renderChatList();
}

/* Mark messages read for current chat */
function markReadCurrentChat(){
  if(!state._lastSeen) state._lastSeen = {};
  const sel = state.selectedChat;
  // store last seen count or timestamp
  if(sel === 'public'){
    state._lastSeen['public'] = (state.messagesCache['public']||[]).length;
    state.unread.public = 0;
  } else {
    state._lastSeen[sel] = (state.messagesCache['dms'] && state.messagesCache['dms'][dmId(state.me.id, sel.split(':')[1])] || []).length;
    state.unread[sel] = 0;
  }
  updateUnreadBadges();
}

/* =======================
   File attachment handling
   ======================= */
attachBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', async (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  if(f.size > 4*1024*1024){ alert('File exceeds 4MB'); return; }
  const base64 = await fileToBase64(f);
  // prepare a file object and place it in the message text area as preview
  txtMessage.value += ` [file:${f.name}] `;
  // store temporarily on input element
  fileInput._pendingFile = { name: f.name, type: f.type, data: base64 };
});

async function fileToBase64(file){
  return new Promise((res, rej)=>{
    const reader = new FileReader();
    reader.onload = ()=> res(reader.result);
    reader.onerror = ()=> rej('err');
    reader.readAsDataURL(file);
  });
}

/* ---------------------
   send button handler
   --------------------- */
sendBtn.addEventListener('click', async ()=>{
  await handleSend();
});
txtMessage.addEventListener('keydown', async (ev)=>{
  if(ev.key === 'Enter' && !ev.shiftKey){
    ev.preventDefault();
    await handleSend();
  }
});

async function handleSend(){
  const text = txtMessage.value;
  const pendingFile = fileInput._pendingFile || null;
  const to = state.selectedChat;
  const file = pendingFile;
  await sendMessage({ to, text, file });
  txtMessage.value = '';
  fileInput.value = ''; fileInput._pendingFile = null;
  // reset unread for the chat
  markReadCurrentChat();
}

/* ==========================
   Chat selection / UI
   ==========================*/
function selectChat(chatId){
  state.selectedChat = chatId;
  // update title
  if(chatId === 'public') chatTitle.textContent = 'Public Chat';
  else if(chatId.startsWith('dm:')){
    const id = chatId.split(':')[1];
    const u = state.usersCache[id] || { username: 'Unknown' };
    chatTitle.textContent = `DM with ${u.username}`;
  }
  renderMessagesForCurrentChat();
  markReadCurrentChat();
}

/* ==========================
   Delete user admin
   ==========================*/
async function deleteUserAndMessages(userId){
  if(!state.me || state.me.username !== ADMIN_USERNAME) { alert('Admin only'); return; }
  if(state.usersCache[userId] && state.usersCache[userId].username === ADMIN_USERNAME){
    alert('Cannot delete admin user.');
    return;
  }
  if(!confirm('Delete user and all their messages? This is irreversible.')) return;
  // mark user deleted
  await update(dbRef(`users/${userId}`), { deleted: true });
  // delete from login list and messages:
  // public messages
  const pub = state.messagesCache['public'] || [];
  for(const m of pub){
    if(m.fromId === userId) await remove(dbRef(`messages/public/${m.id}`));
  }
  // dms: remove any dms that involve user and all messages in them
  const dms = state.messagesCache['dms'] || {};
  for(const dmid of Object.keys(dms)){
    if(dmid.includes(userId)){
      await remove(dbRef(`messages/dms/${dmid}`));
    } else {
      // also remove individual messages from that user in other dms
      for(const m of dms[dmid]){
        if(m.fromId === userId){
          await remove(dbRef(`messages/dms/${dmid}/messages/${m.id}`));
        }
      }
    }
  }
  alert('User deleted and messages removed.');
}

/* ============================
   Auto cleanup (run from clients)
   ============================*/
async function runCleanup(){
  // Messages older than MESSAGE_TTL removed
  const now = Date.now();
  // public
  const pub = state.messagesCache['public'] || [];
  for(const m of pub){
    if(now - (m.ts || 0) > MESSAGE_TTL){
      await remove(dbRef(`messages/public/${m.id}`));
    }
  }
  // dms
  const dms = state.messagesCache['dms'] || {};
  for(const [dmid, msgs] of Object.entries(dms)){
    for(const m of msgs){
      if(now - (m.ts || 0) > MESSAGE_TTL){
        await remove(dbRef(`messages/dms/${dmid}/messages/${m.id}`));
      }
    }
  }
  // idle users older than IDLE_USER_TTL — delete them
  const users = state.usersCache || {};
  for(const [id,u] of Object.entries(users)){
    if(u.username === ADMIN_USERNAME) continue;
    if(u.deleted) continue;
    const last = u.lastActive || u.createdAt || 0;
    if(now - last > IDLE_USER_TTL){
      // delete user
      await update(dbRef(`users/${id}`), { deleted: true });
      // remove their messages similar to deleteUserAndMessages
      // public
      for(const m of (state.messagesCache['public']||[])){
        if(m.fromId === id) await remove(dbRef(`messages/public/${m.id}`));
      }
      // dms
      for(const [dmid, msgs2] of Object.entries(state.messagesCache['dms']||{})){
        if(dmid.includes(id)){
          await remove(dbRef(`messages/dms/${dmid}`));
        } else {
          for(const m of msgs2){
            if(m.fromId === id) await remove(dbRef(`messages/dms/${dmid}/messages/${m.id}`));
          }
        }
      }
    }
  }
}

/* ===========================
   Helpers: censorship, timeago
   ===========================*/
function censorText(s){
  if(!s) return s;
  let out = s;
  for(const w of BLACKLIST){
    const regex = new RegExp(w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),'ig');
    out = out.replace(regex, (m)=> '*'.repeat(m.length));
  }
  return out;
}

function timeAgo(ts){
  const diff = Date.now() - (ts||0);
  if(diff < 60*1000) return 'just now';
  if(diff < 60*60*1000) return Math.floor(diff/60000)+'m';
  if(diff < 24*60*60*1000) return Math.floor(diff/3600000)+'h';
  return Math.floor(diff/86400000)+'d';
}

/* ========================
   UI interactions & events
   ========================*/
btnPublic.onclick = ()=> selectChat('public');
refreshListBtn.onclick = ()=> fetchUsersAndRender();
readMessagesBtn.onclick = ()=> markReadCurrentChat();

volumeSlider.addEventListener('input', (e)=>{
  const v = clamp(Number(e.target.value)/100, 0, 1);
  state.pingVolume = v;
});

logoutBtn.addEventListener('click', ()=>{
  // simple logout
  state.me = null;
  openLoginOverlay();
});

// settings / new
el('#btn-new').onclick = ()=> openLoginOverlay();
el('#btn-settings').onclick = ()=> {
  if(!state.me) { alert('Please login.'); openLoginOverlay(); return; }
  alert('Settings placeholder — you are: ' + state.me.username);
};

/* ==========================
   Initial bootstrap & listeners
   ==========================*/
async function afterLogin(){
  // store me to state and attach listeners
  state._lastSeen = state._lastSeen || {};
  // fetch users & messages
  fetchUsersAndRender();
  listenMessages();
  // ensure my lastActive recorded
  await update(dbRef(`users/${state.me.id}`), { lastActive: Date.now() });
  // select public by default
  selectChat('public');
  // start periodic cleanup
  setInterval(()=> runCleanup().catch(()=>{}), 1000 * 60 * 10); // every 10 minutes
  // periodic lastActive update
  setInterval(()=> {
    if(state.me) update(dbRef(`users/${state.me.id}`), { lastActive: Date.now() });
  }, 1000 * 60 * 2);
}

/* =====================
   Startup: initial load
   =====================*/
(async function init(){
  // show login overlay
  openLoginOverlay();
  // fetch initial users to populate overlay
  fetchUsersAndRender();

  // Attach click handler to accounts list that will prompt login
  accountsList.addEventListener('click', (e)=>{
    const acc = e.target.closest('.account');
    if(!acc) return;
    const userId = acc.dataset.userid;
    const user = state.usersCache[userId];
    promptLogin(userId, user.username);
  });

  // keyboard shortcut: @ to open mention helper (basic)
  txtMessage.addEventListener('keydown', (ev)=>{
    // nothing fancy here
  });

  // When the page is unloaded, mark me offline time
  window.addEventListener('beforeunload', ()=>{
    if(state.me) update(dbRef(`users/${state.me.id}`), { lastActive: Date.now() });
  });

})();

/* =============================
   Helpers: convert text to safe html etc
   =============================*/

function formatTextForStorage(txt){
  return censorText(txt);
}

/* =============================
   Utility: convert DataURL to Blob (not currently used)
   =============================*/
function dataURLtoBlob(dataurl) {
  var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
      bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
  while(n--){
      u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], {type:mime});
}

/* =============================
   Helper: prompt login if someone clicks an existing account in overlay
   =============================*/

// small helper: open DM with a user
function openDMWith(id){
  selectChat('dm:'+id);
}

/* =============================
   Small improvement: observe DB for changes to unread counts
   =============================*/
onValue(dbRef('messages'), snap=>{
  // naive unread incrementing handled locally, we won't compute server-side unread counts
  // but update badges
  // set public unread to 0 by default if none
  if(!state.unread.public) state.unread.public = 0;
  updateUnreadBadges();
});

/* =============================
   Helpful dev: show state on console for debugging
   =============================*/
window.HappeeChat2State = state;

</script>
</body>
</html>
