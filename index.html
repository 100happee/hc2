<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HappeeChat2</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0f12;
      --panel:#0f1418;
      --muted:#98a0a8;
      --accent:#4da3ff;
      --highlight:#1b1f24;
      --mention-bg:#3b2f05; /* when you are mentioned (yellow-ish) */
      --mention-text:#1e90ff;
      --danger:#ff6b6b;
      --card:#0d1113;
    }
    html,body{height:100%;margin:0;font-family:'Poppins',system-ui,Segoe UI,Roboto,Arial;}
    body{background:linear-gradient(180deg,#050608 0%, #071017 100%);color:#e6eef6;display:flex;align-items:stretch;justify-content:center;padding:18px;}
    .app{width:1200px;height:760px;border-radius:12px;overflow:hidden;display:grid;grid-template-columns:260px 1fr;box-shadow: 0 12px 40px rgba(0,0,0,0.6);background:linear-gradient(180deg,var(--panel),#06080b);}
    /* left bar */
    .left{background:rgba(10,12,14,0.9);padding:12px;display:flex;flex-direction:column;gap:10px;}
    .logo{font-weight:700;font-size:18px;color:var(--accent);display:flex;gap:8px;align-items:center}
    .search{padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);outline:none}
    .list{overflow:auto;flex:1;padding-right:6px;margin-top:6px}
    .chat-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;cursor:pointer}
    .chat-item:hover{background:rgba(255,255,255,0.02)}
    .avatar{width:36px;height:36px;border-radius:8px;flex:0 0 36px;background:#18222a;display:inline-block;overflow:hidden}
    .avatar img{width:100%;height:100%;object-fit:cover}
    .name{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .unread{background:var(--accent);padding:4px 6px;border-radius:6px;font-size:12px;color:#031726}
    .footer-left{display:flex;gap:8px;align-items:center;justify-content:space-between;padding-top:8px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
    .btn.primary{background:var(--accent);color:#021220;border:none}
    /* main area */
    .main{display:flex;flex-direction:column}
    .topbar{display:flex;align-items:center;justify-content:space-between;padding:14px;border-bottom:1px solid rgba(255,255,255,0.02)}
    .top-left{display:flex;gap:12px;align-items:center}
    .chat-title{font-weight:600;font-size:16px}
    .top-right{display:flex;gap:12px;align-items:center}
    .volume-range{width:120px}
    .read-btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
    .messages{flex:1;padding:18px;overflow:auto;display:flex;flex-direction:column;gap:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .message{display:flex;gap:12px;align-items:flex-start;padding:10px;border-radius:8px}
    .message:hover{background:rgba(255,255,255,0.01)}
    .msg-body{background:transparent;padding:8px;border-radius:8px;max-width:78%}
    .msg-head{display:flex;gap:8px;align-items:center}
    .msg-username{font-weight:600;margin-right:8px}
    .msg-time{font-size:12px;color:var(--muted)}
    .msg-text{margin-top:6px;white-space:pre-wrap}
    .mention{color:var(--mention-text);font-weight:600}
    .mention-highlight{background:var(--mention-bg);border-radius:6px;padding:6px}
    .attachment{margin-top:8px;display:block;border-radius:8px;padding:6px;border:1px solid rgba(255,255,255,0.03);max-width:480px}
    .input-area{display:flex;gap:8px;padding:12px;border-top:1px solid rgba(255,255,255,0.02);align-items:center}
    .input{flex:1;padding:10px 12px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:inherit;outline:none}
    .file-btn{width:40px;height:40px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;cursor:pointer}
    .send-btn{padding:10px 14px;border-radius:8px;background:var(--accent);border:none;color:#021220;cursor:pointer;font-weight:600}
    .small{font-size:12px;color:var(--muted)}
    .login-overlay{position:absolute;inset:18px;border-radius:12px;background:linear-gradient(180deg,rgba(7,10,13,0.96),rgba(5,7,9,0.98));display:flex;flex-direction:column;padding:24px;z-index:30;backdrop-filter: blur(4px)}
    .login-grid{display:grid;grid-template-columns:340px 1fr;gap:18px;height:100%}
    .account-list{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;overflow:auto}
    .create-form{padding:12px;background:rgba(255,255,255,0.01);border-radius:10px}
    .input-field{display:flex;flex-direction:column;margin-bottom:8px}
    .input-field input,.input-field textarea{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit;outline:none}
    .big-center{display:flex;align-items:center;justify-content:center;flex-direction:column;gap:8px;height:100%}
    .danger{color:var(--danger)}
    .admin-controls{display:flex;gap:8px;align-items:center}
    .delete-user-btn{background:var(--danger);border:none;padding:6px 8px;border-radius:8px;color:white;cursor:pointer}
    /* small helpers */
    a.link { color:var(--accent); text-decoration:underline }
    ::-webkit-scrollbar{height:8px;width:8px}
    ::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.04);border-radius:6px}
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="left">
      <div class="logo">HappeeChat2</div>
      <input id="search" class="search" placeholder="Search users / chats..." />
      <div class="list" id="leftList"></div>
      <div class="footer-left">
        <div class="small">Logged in as <span id="meLabel">Not signed</span></div>
        <div>
          <button class="btn" id="logoutBtn" style="display:none">Logout</button>
          <button class="btn primary" id="createBtn">New Account</button>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="topbar">
        <div class="top-left">
          <div class="chat-title" id="chatTitle">Public Chat</div>
          <div class="small" id="chatMeta"></div>
        </div>
        <div class="top-right">
          <div>
            <label class="small">Ping vol</label><br/>
            <input class="volume-range" id="volume" type="range" min="0" max="1" step="0.01" value="0.8" />
          </div>
          <button class="read-btn" id="readBtn">Read Messages</button>
        </div>
      </div>

      <div class="messages" id="messages"></div>

      <div class="input-area">
        <button class="file-btn" id="fileBtn">+</button>
        <input type="file" id="fileInput" style="display:none" />
        <input id="textInput" class="input" placeholder="Message #public or DM..." />
        <button class="send-btn" id="sendBtn">Send Message</button>
      </div>
    </div>
  </div>

  <!-- Login / create overlay -->
  <div class="login-overlay" id="loginOverlay">
    <div class="login-grid">
      <div>
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <div style="font-weight:700">Choose an account</div>
          <div class="small">Always sign in to use chat</div>
        </div>
        <div class="account-list" id="accountList"></div>
      </div>
      <div>
        <div class="create-form">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">Create account</div>
            <div class="small">Or click an existing account to sign-in</div>
          </div>
          <div style="height:12px"></div>
          <div class="input-field"><label class="small">Username</label><input id="newUsername" placeholder="e.g. Bennett" /></div>
          <div class="input-field"><label class="small">Password</label><input id="newPassword" type="password" placeholder="password" /></div>
          <div class="input-field"><label class="small">Avatar (optional, <=4MB)</label><input id="avatarInput" type="file" accept="image/*" /></div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="btn primary" id="createAccountBtn">Create</button>
            <button class="btn" id="cancelCreateBtn">Cancel</button>
          </div>
          <div style="height:12px"></div>
          <div class="small">Admin account should be created as <strong>100happee</strong> (you will have admin powers)</div>
          <div style="height:8px"></div>
          <div class="small">Blacklisted words: edit at top of script variable <code>BLACKLIST</code></div>
        </div>
      </div>
    </div>
  </div>

  <audio id="pingSound" src="ping.mp3" preload="auto"></audio>

  <script type="module">
  /**************************************************************************
   * HappeeChat2 - single-file web client
   * - Uses Firebase Realtime Database (client)
   * - Stores users/messages/attachments (base64) in DB
   * - Passwords hashed (SHA-256) client-side
   *
   * IMPORTANT: This is a client-side app. For hardened security, use
   * Firebase Auth & server-side Cloud Functions for deletes & scheduled GC.
   **************************************************************************/

  // -------------------- EDITABLE BLACKLIST --------------------
  const BLACKLIST = ["badword","nope","spoiler"]; // change these words to be masked
  // ----------------------------------------------------------------

  // -------------------- FIREBASE CONFIG ---------------------------
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import {
    getDatabase, ref, onValue, set, push, update, remove, get, child, query, orderByChild, limitToFirst
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDkpDlINFiUzR0PsFRcxxk-N2fhHLnpACI",
    authDomain: "hchat2-1d004.firebaseapp.com",
    databaseURL: "https://hchat2-1d004-default-rtdb.firebaseio.com",
    projectId: "hchat2-1d004",
    storageBucket: "hchat2-1d004.firebasestorage.app",
    messagingSenderId: "807685526215",
    appId: "1:807685526215:web:6b9042099ff0b464be24e2"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // -------------------- DOM --------------------
  const leftList = document.getElementById('leftList');
  const accountList = document.getElementById('accountList');
  const loginOverlay = document.getElementById('loginOverlay');
  const meLabel = document.getElementById('meLabel');
  const logoutBtn = document.getElementById('logoutBtn');
  const createBtn = document.getElementById('createBtn');
  const createAccountBtn = document.getElementById('createAccountBtn');
  const cancelCreateBtn = document.getElementById('cancelCreateBtn');
  const newUsername = document.getElementById('newUsername');
  const newPassword = document.getElementById('newPassword');
  const avatarInput = document.getElementById('avatarInput');
  const messagesEl = document.getElementById('messages');
  const chatTitle = document.getElementById('chatTitle');
  const chatMeta = document.getElementById('chatMeta');
  const fileBtn = document.getElementById('fileBtn');
  const fileInput = document.getElementById('fileInput');
  const textInput = document.getElementById('textInput');
  const sendBtn = document.getElementById('sendBtn');
  const readBtn = document.getElementById('readBtn');
  const volume = document.getElementById('volume');
  const pingSound = document.getElementById('pingSound');
  const search = document.getElementById('search');

  // -------------------- STATE --------------------
  let me = null; // { username, avatarBase64, hashedPassword, lastActive }
  let usersCache = {}; // username -> user obj
  let publicMessages = []; // array of messages
  let dmsCache = {}; // dmId -> messages array
  let currentChat = { type: 'public', id: 'public' }; // or {type:'dm', id: username}
  let unreadCounts = {}; // chatId -> count
  let listeners = [];
  let lastKnownMessageTimestamp = 0;

  // Ping volume
  pingSound.volume = parseFloat(volume.value || 0.8);
  volume.addEventListener('input', () => { pingSound.volume = parseFloat(volume.value); });

  // helper: format timestamp like [08/17 at 6:30p]
  function fmtDate(ts){
    const d = new Date(ts);
    const mo = String(d.getMonth()+1).padStart(2,'0');
    const da = String(d.getDate()).padStart(2,'0');
    let hr = d.getHours();
    const am = hr>=12 ? 'p' : 'a';
    if(hr==0) hr=12; else if(hr>12) hr-=12;
    const min = String(d.getMinutes()).padStart(2,'0');
    return `[${mo}/${da} at ${hr}:${min}${am}]`;
  }

  // helper: sha256 hex
  async function sha256hex(message){
    const enc = new TextEncoder();
    const data = enc.encode(message);
    const hash = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
  }

  // -------------------- DATABASE PATHS --------------------
  const usersRef = ref(db, 'users');
  const publicRef = ref(db, 'publicMessages');
  const dmsRef = ref(db, 'dms'); // structure: dms/{dmId}/{pushId}
  const metaRef = ref(db, 'meta'); // meta/unreads/{username}/{chatId}
  const unreadsRefRoot = ref(db, 'unreads');

  // -------------------- UTILITIES --------------------
  function maskBlacklist(text){
    let out = text;
    for(const w of BLACKLIST){
      const re = new RegExp('\\b' + escapeRegExp(w) + '\\b','ig');
      out = out.replace(re, (m)=>'*'.repeat(m.length));
    }
    return out;
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function detectMentions(text){
    const mentions = [];
    const re = /@([a-zA-Z0-9_]+)/g;
    let m;
    while((m=re.exec(text))!==null){
      mentions.push(m[1]);
    }
    return mentions;
  }

  // turns https:// links into anchors; also auto-embed youtube
  function renderTextWithLinks(text){
    // sanitize by escaping HTML
    const esc = text.replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[m]; });
    // replace https links
    const linkified = esc.replace(/https?:\/\/[^\s]+/g, (url)=>{
      // youtube embed?
      const yt = parseYouTube(url);
      if(yt) return `<div class="attachment"><iframe width="420" height="236" src="https://www.youtube.com/embed/${yt.id}" frameborder="0" allowfullscreen></iframe></div>`;
      return `<a class="link" target="_blank" rel="noreferrer noopener" href="${url}">${url}</a>`;
    });
    // handle @mentions: wrap with span
    return linkified.replace(/@([a-zA-Z0-9_]+)/g, (m,uname)=>{
      return `<span class="mention">@${uname}</span>`;
    });
  }

  // parse youtube URL get id
  function parseYouTube(url){
    try{
      const u = new URL(url);
      if(u.hostname.includes('youtube.com')){
        const id = u.searchParams.get('v');
        if(id) return {id};
      } else if(u.hostname === 'youtu.be'){
        const id = u.pathname.slice(1);
        if(id) return {id};
      }
    }catch(e){}
    return null;
  }

  function playPing(){
    try{
      pingSound.currentTime = 0;
      pingSound.play().catch(()=>{/*ignore*/});
    }catch(e){}
  }

  // -------------------- UI RENDER --------------------
  function renderLeftList(){
    leftList.innerHTML = '';
    // public chat entry
    const pubItem = document.createElement('div');
    pubItem.className = 'chat-item';
    pubItem.onclick = ()=>{ switchToPublic(); };
    pubItem.innerHTML = `<div class="avatar"><div style="display:flex;align-items:center;justify-content:center;font-weight:700;color:${'#021220'};background:${'#e8f7ff'};width:100%;height:100%;">#</div></div>
      <div class="name">Public Chat</div>
      <div class="unread" id="unread-public" style="display:none">0</div>`;
    leftList.appendChild(pubItem);

    // DMs: show each user once (excluding current user)
    const names = Object.keys(usersCache).sort((a,b)=>a.localeCompare(b));
    for(const uname of names){
      if(me && uname === me.username) continue;
      const user = usersCache[uname];
      const item = document.createElement('div');
      item.className = 'chat-item';
      item.onclick = ()=>{ openDM(uname) };
      const avatarHTML = `<div class="avatar">${ user && user.avatar ? `<img src="${user.avatar}">` : `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center">${uname.charAt(0).toUpperCase()}</div>` }</div>`;
      const unreadCount = unreadCounts['dm:' + uname] || 0;
      item.innerHTML = `${avatarHTML}<div class="name">${uname}</div><div class="unread" id="unread-dm-${uname}" style="${unreadCount? '':'display:none'}">${unreadCount}</div>`;
      leftList.appendChild(item);
    }
    // update title unread for public
    const pubCount = unreadCounts['public'] || 0;
    const el = document.getElementById('unread-public');
    if(el){ el.style.display = pubCount ? 'inline-block' : 'none'; el.textContent = pubCount; }
    meLabel.textContent = me ? me.username : 'Not signed';
    logoutBtn.style.display = me ? 'inline-block' : 'none';
  }

  function renderMessagesForChat(){
    messagesEl.innerHTML = '';
    if(currentChat.type === 'public'){
      chatTitle.textContent = 'Public Chat';
      chatMeta.textContent = `${publicMessages.length} messages`;
      for(const m of publicMessages){
        messagesEl.appendChild(renderMessageElement(m));
      }
    } else if(currentChat.type === 'dm'){
      chatTitle.textContent = `DM — ${currentChat.id}`;
      const msgs = dmsCache[currentChat.id] || [];
      chatMeta.textContent = `${msgs.length} messages`;
      for(const m of msgs){
        messagesEl.appendChild(renderMessageElement(m));
      }
    }
    // scroll to bottom
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  function renderMessageElement(m){
    const root = document.createElement('div');
    root.className = 'message';
    // highlight if mention and current user is mentioned
    const mentionClass = (me && m.mentions && m.mentions.includes(me.username)) ? 'mention-highlight' : '';
    root.innerHTML = `
      <div class="avatar">${ m.senderAvatar ? `<img src="${m.senderAvatar}" />` : `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center">${m.senderUsername.charAt(0).toUpperCase()}</div>` }</div>
      <div class="msg-body ${mentionClass}">
        <div class="msg-head">
          <div class="msg-username">${escapeHtml(m.senderUsername)}</div>
          <div class="msg-time">${fmtDate(m.timestamp)}</div>
        </div>
        <div class="msg-text">${renderTextWithLinks(maskBlacklist(escapeHtmlForRender(m.text || '')))}</div>
        ${renderAttachments(m.attachments)}
        <div style="margin-top:6px;display:flex;gap:8px;align-items:center">
          ${ (me && me.username === '100happee') ? `<button class="delete-user-btn" data-delete-msg="${m._id}">Delete Msg</button>` : '' }
        </div>
      </div>
    `;
    // attach delete handlers if admin
    const delBtn = root.querySelector('[data-delete-msg]');
    if(delBtn){
      delBtn.addEventListener('click', async (e)=>{
        const id = delBtn.getAttribute('data-delete-msg');
        if(!confirm('Delete this message permanently?')) return;
        await remove(ref(db, `publicMessages/${id}`));
        // also try to remove from dms if present (rare)
      });
    }
    return root;
  }

  function renderAttachments(list){
    if(!list || !list.length) return '';
    return list.map(att=>{
      if(att.type.startsWith('image/')){
        return `<div class="attachment"><a target="_blank" href="${att.data}" download="${att.name}"><img style="max-width:100%;border-radius:8px" src="${att.data}" /></a></div>`;
      } else if(att.type.startsWith('video/')){
        return `<div class="attachment"><video controls style="max-width:100%;border-radius:8px" src="${att.data}"></video><div style="margin-top:6px"><a target="_blank" href="${att.data}" download="${att.name}">Download</a></div></div>`;
      } else if(att.type.startsWith('audio/')){
        return `<div class="attachment"><audio controls src="${att.data}"></audio><div style="margin-top:6px"><a target="_blank" href="${att.data}" download="${att.name}">Download</a></div></div>`;
      } else {
        return `<div class="attachment"><div>${escapeHtml(att.name)}</div><div style="margin-top:6px"><a target="_blank" href="${att.data}" download="${att.name}">Download</a></div></div>`;
      }
    }).join('');
  }

  function escapeHtml(str){
    return (str||'').replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[m]; });
  }
  function escapeHtmlForRender(str){
    // For renderTextWithLinks we double-escape, so this returns raw string used by mask function and then linkify will escape
    return str;
  }

  // -------------------- SWITCH CHAT --------------------
  function switchToPublic(){
    currentChat = {type:'public', id:'public'};
    // clear public unread for me
    if(me){
      set(ref(db, `unreads/${me.username}/public`), 0).catch(()=>{});
      unreadCounts['public'] = 0;
    }
    renderLeftList();
    renderMessagesForChat();
    updateTitleBadge();
  }

  function openDM(username){
    currentChat = {type:'dm', id:username};
    // clear unread for this dm
    if(me){
      set(ref(db, `unreads/${me.username}/dm:${username}`), 0).catch(()=>{});
      unreadCounts['dm:' + username] = 0;
    }
    renderLeftList();
    renderMessagesForChat();
    updateTitleBadge();
  }

  // -------------------- SEND MESSAGE --------------------
  sendBtn.addEventListener('click', sendMessage);
  textInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendMessage(); }});
  fileBtn.addEventListener('click', ()=>fileInput.click());
  fileInput.addEventListener('change', handleFileSelected);

  let pendingAttachment = null; // {name, type, data}

  async function handleFileSelected(e){
    const f = e.target.files[0];
    if(!f) return;
    if(f.size > 4 * 1024 * 1024){ alert('File exceeds 4MB limit'); fileInput.value=''; return; }
    const reader = new FileReader();
    reader.onload = () => {
      pendingAttachment = { name: f.name, type: f.type || 'application/octet-stream', data: reader.result };
      alert('File ready to send: ' + f.name);
    };
    reader.readAsDataURL(f); // base64
  }

  async function sendMessage(){
    if(!me){ alert('Sign in first'); return; }
    const text = (textInput.value || '').trim();
    if(!text && !pendingAttachment){ alert('Enter a message or attach a file'); return; }
    const mentions = detectMentions(text);
    const msg = {
      senderUsername: me.username,
      senderAvatar: me.avatar || null,
      text: text,
      timestamp: Date.now(),
      mentions: mentions,
      attachments: pendingAttachment ? [pendingAttachment] : []
    };
    if(currentChat.type === 'public'){
      // push to publicMessages
      const newRef = push(publicRef);
      msg._id = newRef.key;
      await set(newRef, msg);
      // enforce 500 message limit
      enforcePublicLimit();
    } else {
      // DM to currentChat.id (username)
      const dmId = dmIdentifier(me.username, currentChat.id);
      const newRef = push(ref(db, `dms/${dmId}`));
      msg._id = newRef.key;
      msg.dmWith = currentChat.id;
      await set(newRef, msg);
      // increment unread for target user
      await incrementUnreadForUser(currentChat.id, `dm:${me.username}`);
    }
    // update our lastActive
    await update(ref(db, `users/${me.username}`), { lastActive: Date.now() });
    // clear input
    textInput.value = '';
    pendingAttachment = null;
    fileInput.value = '';
  }

  function dmIdentifier(a,b){
    // deterministic dm id
    return [a,b].sort().join('__');
  }

  async function incrementUnreadForUser(username, chatId){
    const uref = ref(db, `unreads/${username}/${chatId}`);
    // get current
    const snap = await get(uref);
    let val = snap.exists() ? (snap.val()) : 0;
    val = (val || 0) + 1;
    await set(uref, val);
  }

  // -------------------- LISTENERS --------------------
  // watch users list
  onValue(usersRef, (snap)=>{
    const val = snap.val() || {};
    usersCache = val;
    // convert lastActive undefined to 0
    for(const k in usersCache){
      if(!usersCache[k].lastActive) usersCache[k].lastActive = 0;
      if(!usersCache[k].avatar) usersCache[k].avatar = usersCache[k].avatarBase64 || null;
    }
    renderAccountList();
    renderLeftList();
  });

  // watch public messages
  onValue(publicRef, (snap)=>{
    const val = snap.val() || {};
    publicMessages = Object.keys(val).map(k=>({...val[k], _id:k})).sort((a,b)=>a.timestamp - b.timestamp);
    // if current chat is public, render
    if(currentChat.type === 'public') renderMessagesForChat();
    // compute unread increments for me if messages from others while not viewing
    if(me){
      // find newest timestamp
      const newestTs = publicMessages.length ? publicMessages[publicMessages.length-1].timestamp : 0;
      if(newestTs > lastKnownMessageTimestamp){
        // count messages since lastKnownMessageTimestamp not from me
        const newMsgs = publicMessages.filter(m=>m.timestamp > lastKnownMessageTimestamp && m.senderUsername !== me.username);
        if(newMsgs.length){
          if(currentChat.type !== 'public'){
            // increment unread counter locally and in DB
            const current = unreadCounts['public'] || 0;
            unreadCounts['public'] = current + newMsgs.length;
            set(ref(db, `unreads/${me.username}/public`), unreadCounts['public']).catch(()=>{});
          } else {
            // if viewing public, set unreads to 0
            unreadCounts['public'] = 0;
            set(ref(db, `unreads/${me.username}/public`), 0).catch(()=>{});
          }
          // play ping for each new message
          if(newMsgs.length) playPing();
        }
      }
      lastKnownMessageTimestamp = newestTs;
    }
    renderLeftList();
    updateTitleBadge();
  });

  // watch dms root (for live updates we retrieve per-dm when opening)
  onValue(dmsRef, (snap)=>{
    const val = snap.val() || {};
    // store per-dm arrays
    dmsCache = {};
    for(const dmId in val){
      dmsCache[dmId] = Object.keys(val[dmId]).map(k=>({...val[dmId][k], _id:k}));
      // Sort
      dmsCache[dmId].sort((a,b)=>a.timestamp - b.timestamp);
    }
    // if current chat is DM, render the specific one
    if(currentChat.type === 'dm'){
      // find deterministic id for users
      const dmId = dmIdentifier(me ? me.username : '', currentChat.id);
      renderMessagesForChat();
    }
    // compute unreads for me
    if(me){
      // for each dm involving me, check latest messages not from me and whether viewing
      for(const dmId in dmsCache){
        const msgs = dmsCache[dmId];
        if(!msgs.length) continue;
        // determine other user
        const others = dmId.split('__').filter(x=>x && me && x !== me.username);
        if(others.length!==1) continue;
        const other = others[0];
        const lastTs = msgs[msgs.length-1].timestamp;
        if(currentChat.type==='dm' && currentChat.id===other){
          // viewing -> zero unread
          unreadCounts['dm:' + other] = 0;
          set(ref(db, `unreads/${me.username}/dm:${other}`), 0).catch(()=>{});
        } else {
          // count messages from other after our last known?
          const newMsgs = msgs.filter(m=>m.timestamp > (Date.now()-1000*60*60*24*7) && m.senderUsername === other); // heuristics
          if(newMsgs.length) {
            unreadCounts['dm:' + other] = unreadCounts['dm:' + other] ? unreadCounts['dm:' + other] + newMsgs.length : newMsgs.length;
          }
        }
      }
      // write back local unreads to DB for consistency
      for(const key in unreadCounts){
        const val = unreadCounts[key];
        if(key==='public') set(ref(db, `unreads/${me.username}/public`), val).catch(()=>{});
        else if(key.startsWith('dm:')){
          const uname = key.split(':')[1];
          set(ref(db, `unreads/${me.username}/dm:${uname}`), val).catch(()=>{});
        }
      }
    }
    renderLeftList();
    updateTitleBadge();
  });

  // watch unreads for me (if logged in)
  function watchUnreadsForUser(username){
    const uref = ref(db, `unreads/${username}`);
    onValue(uref, (snap)=>{
      const val = snap.val() || {};
      // val structure: { public: 0, "dm:other": N }
      unreadCounts = {};
      if(val.public) unreadCounts['public'] = val.public;
      for(const k in val){
        if(k.startsWith('dm:')) unreadCounts[k] = val[k];
      }
      renderLeftList();
      updateTitleBadge();
    });
  }

  // update page title with unread bracket
  function updateTitleBadge(){
    const total = Object.values(unreadCounts).reduce((s,v)=>s+(v||0),0);
    document.title = (total? `[${total}] ` : '') + 'HappeeChat2';
  }

  readBtn.addEventListener('click', ()=>{
    if(!me) return;
    // mark all as read
    set(ref(db, `unreads/${me.username}`), {}).catch(()=>{});
    unreadCounts = {};
    renderLeftList();
    updateTitleBadge();
  });

  // -------------------- ACCOUNTS UI --------------------
  function renderAccountList(){
    accountList.innerHTML = '';
    const list = Object.keys(usersCache).sort((a,b)=>a.localeCompare(b));
    for(const uname of list){
      const u = usersCache[uname];
      const item = document.createElement('div');
      item.className = 'chat-item';
      item.style.justifyContent = 'space-between';
      const left = document.createElement('div');
      left.style.display='flex';
      left.style.gap='10px';
      left.style.alignItems='center';
      left.innerHTML = `<div class="avatar">${ u.avatar ? `<img src="${u.avatar}">` : `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center">${uname.charAt(0).toUpperCase()}</div>` }</div><div style="display:flex;flex-direction:column"><div style="font-weight:600">${escapeHtml(uname)}</div><div class="small">Click to login</div></div>`;
      item.appendChild(left);
      const btns = document.createElement('div');
      const loginBtn = document.createElement('button'); loginBtn.className='btn'; loginBtn.textContent='Login';
      loginBtn.addEventListener('click', ()=>promptPasswordAndLogin(uname));
      btns.appendChild(loginBtn);
      item.appendChild(btns);
      accountList.appendChild(item);
    }
  }

  // prompt password and login
  async function promptPasswordAndLogin(username){
    const pwd = prompt(`Enter password for ${username}:`);
    if(pwd === null) return;
    const hashed = await sha256hex(pwd);
    // fetch user
    const snap = await get(ref(db, `users/${username}`));
    if(!snap.exists()){ alert('User not found'); return; }
    const u = snap.val();
    if(u.passwordHash === hashed){
      // login success
      me = {...u, username};
      // ensure avatar key named avatar
      me.avatar = u.avatar || u.avatarBase64 || null;
      me.lastActive = Date.now();
      // persist to localStorage (so they remain signed across reloads, but login screen will still show)
      localStorage.setItem('hchat_user', JSON.stringify({username, passwordHash:hashed}));
      // set lastActive in DB
      await update(ref(db, `users/${username}`), { lastActive: Date.now() });
      loginOverlay.style.display = 'none';
      meLabel.textContent = me.username;
      // watch unreads for me
      watchUnreadsForUser(me.username);
      // set up auto-deletion housekeeping on login
      runHousekeeping();
      renderLeftList();
      switchToPublic();
    } else {
      alert('Incorrect password');
    }
  }

  // create account
  createAccountBtn.addEventListener('click', async ()=>{
    const uname = (newUsername.value || '').trim();
    const pwd = newPassword.value || '';
    if(!uname.match(/^[a-zA-Z0-9_]{3,32}$/)){ alert('Username must be 3-32 chars, letters/numbers/_ only'); return; }
    if(!pwd || pwd.length < 4){ alert('Password must be at least 4 characters'); return; }
    // check uniqueness
    const snap = await get(ref(db, `users/${uname}`));
    if(snap.exists()){ alert('Username already exists'); return; }
    // process avatar file if any
    let avatarBase64 = null;
    if(avatarInput.files && avatarInput.files[0]){
      const f = avatarInput.files[0];
      if(f.size > 4 * 1024 * 1024){ alert('Avatar exceeds 4MB'); return; }
      avatarBase64 = await new Promise(res=>{
        const r = new FileReader();
        r.onload = ()=>res(r.result);
        r.readAsDataURL(f);
      });
    }
    const pwdHash = await sha256hex(pwd);
    const userObj = { passwordHash: pwdHash, avatar: avatarBase64 || null, createdAt: Date.now(), lastActive: Date.now() };
    // write to DB
    await set(ref(db, `users/${uname}`), userObj);
    // auto-log them in
    newUsername.value = ''; newPassword.value=''; avatarInput.value='';
    alert('Account created! Please sign in (press login on the account list).');
    // auto refresh account list handled by onValue listener
  });

  cancelCreateBtn.addEventListener('click', ()=>{ newUsername.value=''; newPassword.value=''; avatarInput.value=''; });

  createBtn.addEventListener('click', ()=>{ loginOverlay.style.display='block'; });

  logoutBtn.addEventListener('click', ()=>{
    me = null;
    localStorage.removeItem('hchat_user');
    loginOverlay.style.display = 'block';
    renderLeftList();
  });

  // auto sign-in if localStorage present, but still show overlay (you must enter password each reload per spec) -> The spec said: "This happens every time you join or reload the website." So DO NOT auto-login.
  // However we will pre-fill username if available.
  (function prefillFromLocal(){
    try{
      const s = localStorage.getItem('hchat_user');
      if(s){
        const obj = JSON.parse(s);
        if(obj && obj.username) {
          // prefill - but per your spec we require password entry each time, so do not auto login
          // we set focus to login overlay and show account list
          loginOverlay.style.display = 'block';
        }
      } else {
        loginOverlay.style.display = 'block';
      }
    }catch(e){ loginOverlay.style.display = 'block'; }
  })();

  // -------------------- STARTUP HOUSEKEEPING (auto-delete) --------------------
  async function runHousekeeping(){
    // Delete public messages older than 7 days
    try{
      const sevenDaysAgo = Date.now() - 7*24*60*60*1000;
      const snap = await get(publicRef);
      if(snap.exists()){
        const all = snap.val();
        for(const id in all){
          const msg = all[id];
          if(msg.timestamp < sevenDaysAgo){
            await remove(ref(db, `publicMessages/${id}`));
          }
        }
      }
      // Delete idle users (over 30 days), except 100happee
      const thirtyDaysAgo = Date.now() - 30*24*60*60*1000;
      const usersSnap = await get(usersRef);
      if(usersSnap.exists()){
        const all = usersSnap.val();
        for(const uname in all){
          if(uname === '100happee') continue;
          const u = all[uname];
          if((u.lastActive || u.createdAt || 0) < thirtyDaysAgo){
            // delete their messages and dms
            await deleteUserData(uname);
          }
        }
      }
      // ensure public message limit 500
      await enforcePublicLimit();
    }catch(e){ console.error('Housekeeping error', e); }
  }

  async function enforcePublicLimit(){
    const snap = await get(publicRef);
    if(!snap.exists()) return;
    const all = snap.val();
    const arr = Object.keys(all).map(k=>({...all[k], _id:k})).sort((a,b)=>a.timestamp - b.timestamp);
    if(arr.length > 500){
      const toRemove = arr.slice(0, arr.length - 500);
      for(const m of toRemove){
        await remove(ref(db, `publicMessages/${m._id}`));
      }
    }
  }

  // -------------------- DELETE USER (ADMIN) --------------------
  // remove user record and their public messages & dms
  async function deleteUserData(username){
    // remove public messages by them
    const pubSnap = await get(publicRef);
    if(pubSnap.exists()){
      const all = pubSnap.val();
      for(const id in all){
        if(all[id].senderUsername === username){
          await remove(ref(db, `publicMessages/${id}`));
        }
      }
    }
    // remove dms where sender = username OR member = username
    const dmsSnap = await get(dmsRef);
    if(dmsSnap.exists()){
      const all = dmsSnap.val();
      for(const dmId in all){
        const msgs = all[dmId];
        // delete all messages from username in that dm
        for(const msgId in msgs){
          if(msgs[msgId].senderUsername === username){
            await remove(ref(db, `dms/${dmId}/${msgId}`));
          }
        }
        // if DM now empty or DM only involves that user, remove entire dm branch
        const after = await get(ref(db, `dms/${dmId}`));
        if(!after.exists()){
          await remove(ref(db, `dms/${dmId}`));
        } else {
          // if dmId contains only that user and another who maybe is also deleted, leave as-is
        }
      }
    }
    // remove user record
    await remove(ref(db, `users/${username}`));
    // remove unreads entries for user
    await remove(ref(db, `unreads/${username}`));
  }

  // admin delete user control in DM view
  // add event listener globally: when viewing a user's DM, show delete-user button at top
  function renderAdminControlsIfNeeded(){
    // top-right area: we'll add a delete user button if admin and viewing a DM
    const existing = document.getElementById('adminDeleteUserBtn');
    if(existing) existing.remove();
    if(me && me.username === '100happee' && currentChat.type === 'dm'){
      const btn = document.createElement('button');
      btn.id = 'adminDeleteUserBtn';
      btn.className = 'delete-user-btn';
      btn.textContent = 'Delete User';
      btn.addEventListener('click', async ()=>{
        if(!confirm(`Delete user ${currentChat.id} and all of their messages? This cannot be undone.`)) return;
        if(currentChat.id === '100happee'){ alert('Cannot delete admin'); return; }
        await deleteUserData(currentChat.id);
        // if we were viewing them, switch to public
        switchToPublic();
        alert('User deleted.');
      });
      document.querySelector('.top-right').appendChild(btn);
    }
  }

  // re-render admin controls when chat switches
  const origRenderMessagesForChat = renderMessagesForChat;
  renderMessagesForChat = function(){
    origRenderMessagesForChat();
    renderAdminControlsIfNeeded();
  }

  // -------------------- WATCH UNREADS (global) --------------------
  // For each user in DB we could watch their unreads, but that's heavy.
  // Instead, when me changes, set a watch on my unreads only (handled above via watchUnreadsForUser).

  // -------------------- UTILITY: periodically refresh housekeeping --------------------
  setInterval(()=>{ if(me) runHousekeeping(); }, 1000*60*30); // every 30 minutes

  // -------------------- Utility escape for rendering safe html in links (we used earlier) --------------------

  // -------------------- Start: small initializations --------------------
  // Add search filtering on left list
  search.addEventListener('input', ()=>{
    const q = (search.value || '').toLowerCase();
    const children = leftList.children;
    for(const el of Array.from(children)){
      const nameEl = el.querySelector('.name');
      if(!nameEl) continue;
      const txt = nameEl.textContent.toLowerCase();
      el.style.display = txt.includes(q) ? '' : 'none';
    }
  });

  // update admin controls when switching chat
  const origSwitchToPublic = switchToPublic;
  switchToPublic = function(){ origSwitchToPublic(); renderAdminControlsIfNeeded(); }

  const origOpenDM = openDM;
  openDM = function(uname){ origOpenDM(uname); renderAdminControlsIfNeeded(); }

  // -------------------- Extra: allow message delete by hovering for admin (per your spec) --------------------
  // We added delete buttons beside each message for admin.

  // -------------------- INITIAL RUN --------------------
  // call housekeeping at startup
  runHousekeeping().catch(()=>{});

  // Listen for unreads root changes to show counts in left list as well (if me is set, watchUnreadsForUser will do)
  // nothing further here

  // End of module
  </script>
</body>
</html>
