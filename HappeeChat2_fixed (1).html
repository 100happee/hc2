<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HappeeChat2</title>
<link rel="icon" href="https://i1.sndcdn.com/avatars-V22Gw2FsnsI9xMuU-ihNrRA-t240x240.jpg" />
<!-- Poppins font -->
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0e12;
    --panel:#0f1419;
    --muted:#8b97a6;
    --accent:#4da3ff;
    --contrast:#12161a;
    --bubble:#0e1317;
    --mention:#f5d35b;
    --mention-text:#1a1a1a;
    --max-width:1200px;
    font-family: 'Poppins', sans-serif;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071017 0%, #04060a 100%);color:#e6eef6}
  .app {
    max-width:var(--max-width);
    margin:18px auto;
    height:88vh;
    display:flex;
    gap:12px;
    border-radius:12px;
    overflow:hidden;
    box-shadow:0 10px 30px rgba(0,0,0,0.6);
  }
  /* Left column (now only small toolbar) */
  .left {
    width:88px;
    background:var(--panel);
    padding:12px 8px;
    display:flex;
    flex-direction:column;
    gap:8px;
    box-sizing:border-box;
  }
  .icon-btn {
    width:64px;height:64px;border-radius:10px;display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
    border:1px solid rgba(255,255,255,0.03);
    cursor:pointer;position:relative;overflow:hidden;
  }
  .icon-btn .badge {position:absolute;right:6px;top:6px;background:#ff6b6b;color:white;padding:2px 6px;border-radius:6px;font-size:11px}
  .icon-btn img, .icon-btn .hash {width:42px;height:42px;border-radius:8px;object-fit:cover}
  .icon-btn .hash {font-weight:700;color:var(--accent);font-size:34px}
  .bottom-left {margin-top:auto;display:flex;flex-direction:column;gap:8px;align-items:center}
  /* Middle column (users list / chats) */
  .middle {
    width:260px;
    background:var(--panel);
    padding:12px;
    display:flex;
    flex-direction:column;
    gap:8px;
    box-sizing:border-box;
  }
  .chat-list {overflow:auto;flex:1;padding-top:6px}
  .chat-item {display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;cursor:pointer}
  .chat-item:hover{background:rgba(255,255,255,0.02)}
  .chat-item img {width:44px;height:44px;border-radius:8px;object-fit:cover}
  .chat-item .meta {display:flex;flex-direction:column}
  .chat-item .meta .name {font-weight:600}
  .unread-count {margin-left:auto;background:#2b6aab;padding:4px 6px;border-radius:6px;font-size:12px}
  /* Right column (messages) */
  .right {
    flex:1;
    background:linear-gradient(180deg,var(--contrast),#081017);
    display:flex;flex-direction:column;padding:12px;box-sizing:border-box;
  }
  .header {
    display:flex;align-items:center;gap:12px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.02);
  }
  .header .title {font-size:18px;font-weight:700}
  .header .controls {margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn {background:var(--accent);color:#06121a;padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
  .btn.ghost{background:transparent;color:var(--accent);border:1px solid rgba(255,255,255,0.04)}
  .read-btn{background:#334153;color:white;padding:6px 8px;border-radius:8px}
  .volume {display:flex;align-items:center;gap:8px}
  .volume input[type=range]{width:120px}
  .messages {flex:1;overflow:auto;padding:12px;display:flex;flex-direction:column;gap:12px}
  .message {display:flex;gap:12px;align-items:flex-start;padding:8px;border-radius:8px;background:transparent;transition:background 120ms}
  .message:hover{background:rgba(255,255,255,0.01)}
  .message .avatar {width:48px;height:48px;border-radius:8px;object-fit:cover}
  .message .body {flex:1}
  .message .meta {display:flex;gap:8px;align-items:center}
  .message .username{font-weight:700}
  .message .text{margin-top:6px;white-space:pre-wrap}
  .message .timestamp{font-size:11px;color:var(--muted);margin-left:auto}
  .mention {background:var(--mention);color:var(--mention-text);padding:2px 6px;border-radius:6px}
  .atlink {color:var(--accent);font-weight:700}
  .file-embed {margin-top:8px;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);padding:6px;background: #070a0c}
  .input-row {display:flex;gap:8px;align-items:center;padding-top:8px;border-top:1px solid rgba(255,255,255,0.02)}
  .input-row textarea{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit;min-height:44px;max-height:120px;resize:none}
  .input-row .add-btn{width:44px;height:44px;border-radius:8px;border:1px dashed rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:pointer}
  .small {font-size:12px;color:var(--muted)}
  .login-overlay{position:absolute;inset:0;background:linear-gradient(180deg, rgba(3,6,9,0.6), rgba(3,6,9,0.9));display:flex;align-items:center;justify-content:center;z-index:9999}
  .login-box{width:760px;background:linear-gradient(180deg,#07101a,#081218);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:12px;box-sizing:border-box}
  .login-left{width:320px;padding:8px;display:flex;flex-direction:column;gap:8px}
  .account {display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;cursor:pointer}
  .account img{width:48px;height:48px;border-radius:8px;object-fit:cover}
  .create-form{flex:1;padding:8px;display:flex;flex-direction:column;gap:8px}
  input,button,select,textarea{font-family:inherit}
  .danger{background:#ff6b6b;color:white}
  .admin-delete {margin-left:auto;background:#7b2634;color:#fff;padding:6px;border-radius:8px;border:none;cursor:pointer}
  .no-messages {text-align:center;color:var(--muted);margin-top:24px}
  /* highlight for mention */
  .mentioned {background:linear-gradient(90deg,#3b2b03,#5a4710);border-radius:8px}
  /* small adjustments for responsiveness */
  @media(max-width:900px){
    .middle{display:none}
    .left{width:64px}
    .login-box{width:94%}
  }
</style>
</head>
<body>
<div style="position:relative">
  <div class="app" id="app">
    <div class="left">
      <!-- left column simplified: removed duplicate channel icons list per request -->
      <div class="bottom-left">
        <div title="Create / Accounts" id="btn-new" class="icon-btn">+</div>
        <div title="Settings / Logout" id="btn-settings" class="icon-btn">⚙</div>
      </div>
    </div>

    <div class="middle">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <div style="font-weight:700">Chats</div>
        <div class="small" id="online-count">0 online</div>
      </div>
      <div class="chat-list" id="chat-list"></div>
    </div>

    <div class="right">
      <div class="header">
        <div class="title" id="chat-title">Public Chat</div>
        <div class="controls" id="header-controls">
          <div class="small">Ping vol</div>
          <div class="volume">
            <input id="volume-slider" type="range" min="0" max="100" value="70"/>
          </div>
          <button id="read-messages" class="read-btn small">Read Messages</button>
          <button id="logout" class="btn ghost small">Logout</button>
        </div>
      </div>

      <div id="dm-header-area" style="display:none"></div>

      <div class="messages" id="messages"></div>

      <div class="input-row">
        <label class="add-btn" title="Attach file" id="attach-btn">+</label>
        <input type="file" id="file-input" style="display:none" />
        <textarea id="txt-message" placeholder="Write a message..."></textarea>
        <button id="send-btn" class="btn">Send Message</button>
      </div>
    </div>
  </div>

  <!-- Login / Create account overlay: create form first, accounts list below -->
  <div class="login-overlay" id="login-overlay">
    <div class="login-box">
      <div class="create-form">
        <div style="display:flex;gap:8px;align-items:center">
          <div style="font-weight:700">Create new account</div>
          <div class="small" style="margin-left:auto">Admin username: <code>100happee</code></div>
        </div>
        <input id="new-username" placeholder="username (unique)" />
        <input id="new-password" type="password" placeholder="password" />
        <div style="display:flex;gap:8px;align-items:center">
          <input id="avatar-file" type="file" accept="image/*" />
          <div id="avatar-preview" style="width:48px;height:48px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center">avatar</div>
        </div>
        <div style="display:flex;gap:8px">
          <button id="create-account" class="btn">Create account</button>
        </div>
        <div id="login-msg" class="small" style="margin-top:8px;color:var(--muted)"></div>
        <div style="height:12px"></div>
        <div style="font-weight:700">Existing accounts</div>
        <div class="small">Click an account to login (you will be prompted for the password).</div>
      </div>

      <div class="login-left">
        <div style="font-size:18px;font-weight:800">Welcome to HappeeChat2</div>
        <div class="small">Choose an account or create a new one</div>
        <div id="accounts-list" style="margin-top:12px;overflow:auto"></div>
      </div>
    </div>
  </div>
</div>

<!-- ping sound -->
<audio id="ping-audio" src="./ping.mp3" preload="auto"></audio>

<!-- Firebase SDK (modular) -->
<script type="module">
/* ============================
   HappeeChat2 — Single-file app (fixed)
   ============================
   Edits made: removed duplicate login click, removed left duplicated channel list,
   moved delete-user button to header, removed search/refresh UI elements,
   reordered login overlay so create account appears first.
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
import { getDatabase, ref, onValue, set, push, remove, get, child, update, query, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

/* -----------------------
   Firebase config (you provided)
   -----------------------*/
const firebaseConfig = {
  apiKey: "AIzaSyDkpDlINFiUzR0PsFRcxxk-N2fhHLnpACI",
  authDomain: "hchat2-1d004.firebaseapp.com",
  databaseURL: "https://hchat2-1d004-default-rtdb.firebaseio.com",
  projectId: "hchat2-1d004",
  storageBucket: "hchat2-1d004.firebasestorage.app",
  messagingSenderId: "807685526215",
  appId: "1:807685526215:web:6b9042099ff0b464be24e2"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ===============================
   CONFIG / variables you can edit
   =============================== */
const BLACKLIST = ["badword","anotherbadword"]; // <<--- edit here
const MESSAGE_TTL = 7 * 24 * 60 * 60 * 1000; // 7 days
const IDLE_USER_TTL = 30 * 24 * 60 * 60 * 1000; // 30 days
const PUBLIC_CHAT_LIMIT = 500;
const ADMIN_USERNAME = "100happee";

/* ------------------------------
   Utilities
   ------------------------------*/
function el(sel){return document.querySelector(sel)}
function q(sel){return document.querySelectorAll(sel)}
function uid(){ return 'id_' + Math.random().toString(36).slice(2,9); }
function formatTimestamp(ts){
  const d = new Date(ts);
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  let hh = d.getHours(); const ampm = hh>=12? 'p' : 'a';
  hh = hh % 12; if(hh===0) hh=12;
  const min = String(d.getMinutes()).padStart(2,'0');
  return `${mm}/${dd} at ${hh}:${min}${ampm}`;
}
async function sha256hex(str){
  const enc = new TextEncoder();
  const data = enc.encode(str);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
}
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

/* ================================
   App state
   ================================*/
let state = {
  me: null,
  selectedChat: 'public',
  usersCache: {},
  unread: {},
  messagesCache: {},
  pingVolume: 0.7
};

/* ================
   DOM refs
   ================*/
const loginOverlay = el('#login-overlay');
const accountsList = el('#accounts-list');
const createBtn = el('#create-account');
const avatarFile = el('#avatar-file');
const avatarPreview = el('#avatar-preview');
const newUsername = el('#new-username');
const newPassword = el('#new-password');
const loginMsg = el('#login-msg');

const chatList = el('#chat-list');
const messagesArea = el('#messages');
const chatTitle = el('#chat-title');
const txtMessage = el('#txt-message');
const sendBtn = el('#send-btn');
const fileInput = el('#file-input');
const attachBtn = el('#attach-btn');
const readMessagesBtn = el('#read-messages');
const volumeSlider = el('#volume-slider');
const pingAudio = el('#ping-audio');
const logoutBtn = el('#logout');
const onlineCount = el('#online-count');
const headerControls = el('#header-controls');

/* -------------------------
   Firebase helpers
   -------------------------*/
const dbRef = (p)=> ref(db, p);

/* ============================
   Core: users & accounts
   ============================*/
async function fetchUsersAndRender(){
  onValue(dbRef('users'), snapshot => {
    const users = snapshot.val() || {};
    state.usersCache = users;
    renderAccountsList();
    renderChatList();
    updateOnlineCount();
  });
}

function renderAccountsList(){
  accountsList.innerHTML = '';
  const users = state.usersCache;
  const entries = Object.entries(users).sort((a,b)=> (b[1].lastActive||0)-(a[1].lastActive||0));
  for(const [id, u] of entries){
    if(u.deleted) continue;
    const div = document.createElement('div');
    div.className = 'account';
    div.dataset.userid = id;
    div.innerHTML = `<img src="${u.avatar||defaultAvatar(u.username)}" />
      <div style="display:flex;flex-direction:column">
        <div style="font-weight:700">${u.username}</div>
        <div class="small">${u.lastActive?('active '+timeAgo(u.lastActive)): 'never active'}</div>
      </div>`;
    // single place that triggers login prompt
    div.onclick = ()=> promptLogin(id, u.username);
    accountsList.appendChild(div);
  }
}

function defaultAvatar(name){
  const letter = (name||'?').charAt(0).toUpperCase();
  return `https://via.placeholder.com/80/222229/ffffff?text=${encodeURIComponent(letter)}`;
}

function renderChatList(){
  chatList.innerHTML = '';
  // public chat
  const pubEl = document.createElement('div');
  pubEl.className = 'chat-item';
  pubEl.dataset.chat = 'public';
  pubEl.innerHTML = `<div style="width:44px;height:44px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:800;color:var(--accent);background:transparent">#</div>
    <div class="meta"><div class="name">Public Chat</div><div class="small">Main public room</div></div>
    <div class="unread" style="margin-left:auto">${state.unread.public?('<div class="unread-count">'+state.unread.public+'</div>') : ''}</div>`;
  pubEl.onclick = ()=> selectChat('public');
  chatList.appendChild(pubEl);

  // DMs
  const users = state.usersCache;
  const entries = Object.entries(users).filter(([id,u])=> !u.deleted);
  entries.sort((a,b)=> (a[1].username || '').localeCompare(b[1].username));
  for(const [id,u] of entries){
    const elc = document.createElement('div');
    elc.className = 'chat-item';
    elc.dataset.chat = 'dm:'+id;
    elc.innerHTML = `<img src="${u.avatar||defaultAvatar(u.username)}" />
      <div class="meta"><div class="name">${u.username}</div><div class="small">Direct message</div></div>
      ${state.unread['dm:'+id]?('<div class="unread-count">'+state.unread['dm:'+id]+'</div>') : ''}`;
    elc.onclick = ()=> selectChat('dm:'+id);
    chatList.appendChild(elc);
  }
}

function updateOnlineCount(){
  const users = state.usersCache;
  const online = Object.values(users).filter(u=>!u.deleted && (Date.now() - (u.lastActive||0) < 5*60*1000)).length;
  onlineCount.textContent = `${online} online`;
}

/* =================================
   Login / create account flows
   =================================*/
let avatarBase64ForCreate = null;
avatarFile.addEventListener('change', async (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  if(f.size > 4*1024*1024){ alert('Avatar exceeds 4MB'); return; }
  const b = await fileToBase64(f);
  avatarBase64ForCreate = b;
  avatarPreview.innerHTML = `<img src="${b}" style="width:48px;height:48px;border-radius:8px;object-fit:cover" />`;
});

function openLoginOverlay(){
  loginOverlay.style.display = 'flex';
  newUsername.value = '';
  newPassword.value = '';
  avatarBase64ForCreate = null;
  avatarPreview.innerHTML = 'avatar';
}

createBtn.addEventListener('click', async ()=>{
  const username = (newUsername.value||'').trim();
  const password = newPassword.value||'';
  if(!username || !password){ loginMsg.textContent = 'Enter username and password.'; return; }
  const usersSnap = await get(dbRef('users'));
  const users = usersSnap.val() || {};
  for(const [id,u] of Object.entries(users)){
    if(u.username && u.username.toLowerCase() === username.toLowerCase()){
      loginMsg.textContent = 'Username already exists.';
      return;
    }
  }
  const id = uid();
  const hashed = await sha256hex(password);
  const userObj = {
    username,
    avatar: avatarBase64ForCreate || defaultAvatar(username),
    createdAt: Date.now(),
    lastActive: Date.now(),
    pwHash: hashed,
    deleted: false
  };
  await set(dbRef(`users/${id}`), userObj);
  loginMsg.textContent = 'Account created. Click your account to login.';
  fetchUsersAndRender();
});

function promptLogin(userId, username){
  const pw = prompt(`Enter password for ${username}`);
  if(pw === null) return;
  attemptLogin(userId, pw);
}

async function attemptLogin(userId, pw){
  const snap = await get(dbRef(`users/${userId}`));
  const u = snap.val();
  if(!u || u.deleted){ alert('Account not found'); return; }
  const h = await sha256hex(pw);
  if(h !== u.pwHash){ alert('Incorrect password'); return; }
  state.me = { id: userId, username: u.username, avatar: u.avatar, lastActive: Date.now() };
  await update(dbRef(`users/${userId}`), { lastActive: Date.now() });
  loginOverlay.style.display = 'none';
  afterLogin();
}

/* ============================
   Messages listening & sending
   ============================*/
function listenMessages(){
  onValue(dbRef('messages/public'), snapshot => {
    const obj = snapshot.val() || {};
    const msgs = Object.entries(obj).map(([id,m])=>({id,...m}));
    msgs.sort((a,b)=> (a.ts||0)-(b.ts||0));
    state.messagesCache['public'] = msgs;
    renderMessagesForCurrentChat();
    if(state.selectedChat !== 'public'){
      state.unread.public = (state.unread.public||0) + msgs.length - (state._lastSeen && state._lastSeen['public']? state._lastSeen['public'] : 0);
      updateUnreadBadges();
    }
    enforcePublicLimit();
  });

  onValue(dbRef('messages/dms'), snapshot => {
    const obj = snapshot.val() || {};
    const map = {};
    for(const [dmid, room] of Object.entries(obj)){
      const messagesObj = room.messages || {};
      const msgs = Object.entries(messagesObj).map(([id,m])=>({id,...m}));
      msgs.sort((a,b)=> (a.ts||0)-(b.ts||0));
      map[dmid] = msgs;
    }
    state.messagesCache['dms'] = map;
    renderMessagesForCurrentChat();
  });
}

async function enforcePublicLimit(){
  const msgs = state.messagesCache['public'] || [];
  if(msgs.length > PUBLIC_CHAT_LIMIT){
    const toRemove = msgs.slice(0, msgs.length - PUBLIC_CHAT_LIMIT);
    for(const m of toRemove){
      await remove(dbRef(`messages/public/${m.id}`));
    }
  }
}

async function sendMessage({to='public', text='', file=null, isDMWith=null}){
  if(!state.me) { alert('Please login'); openLoginOverlay(); return; }
  if(text.trim()==='' && !file){ return; }
  const censored = censorText(text);
  const message = {
    fromId: state.me.id,
    fromUsername: state.me.username,
    avatar: state.me.avatar,
    text: censored,
    ts: Date.now(),
  };
  if(file) message.file = file;

  if(to === 'public'){
    const newRef = push(dbRef('messages/public'));
    await set(newRef, message);
    playPing();
  } else if(to.startsWith('dm:')){
    const otherId = to.split(':')[1];
    const dmid = dmId(state.me.id, otherId);
    const newRef = push(dbRef(`messages/dms/${dmid}/messages`));
    await set(newRef, message);
    playPing();
  }
  await update(dbRef(`users/${state.me.id}`), { lastActive: Date.now() });
}

function dmId(a,b){ return [a,b].sort().join('__'); }
function playPing(){ pingAudio.volume = state.pingVolume; pingAudio.currentTime = 0; pingAudio.play().catch(()=>{}); }

/* Render messages for whichever chat is selected */
function renderMessagesForCurrentChat(){
  const sel = state.selectedChat;
  messagesArea.innerHTML = '';
  // hide dm-header-area (we're using main header now)
  const dmArea = el('#dm-header-area'); if(dmArea) dmArea.style.display = 'none';

  if(sel === 'public'){
    const msgs = state.messagesCache['public'] || [];
    if(msgs.length === 0){
      messagesArea.innerHTML = `<div class="no-messages">No messages yet in public chat.</div>`;
      return;
    }
    for(const m of msgs){
      const el = messageToElement(m, 'public');
      messagesArea.appendChild(el);
    }
  } else if(sel.startsWith('dm:')){
    const other = sel.split(':')[1];
    const dmid = dmId(state.me.id, other);
    const msgs = (state.messagesCache['dms'] && state.messagesCache['dms'][dmid]) || [];
    if(msgs.length === 0){
      messagesArea.innerHTML = `<div class="no-messages">No messages yet in this DM.</div>`;
    } else {
      for(const m of msgs){
        const el = messageToElement(m, dmid);
        messagesArea.appendChild(el);
      }
    }
    // place admin delete user button into header controls when DM selected
    renderHeaderForChat(other);
  }
  messagesArea.scrollTop = messagesArea.scrollHeight;
}

function renderHeaderForChat(otherId){
  // Remove any existing delete-user button in header to avoid duplicates
  const existing = el('#delete-user-btn');
  if(existing) existing.remove();

  const u = state.usersCache[otherId] || { username: 'Unknown' };
  // set chat title
  chatTitle.textContent = `DM with ${u.username}`;

  if(state.me && state.me.username === ADMIN_USERNAME){
    const btn = document.createElement('button');
    btn.id = 'delete-user-btn';
    btn.className = 'admin-delete';
    btn.textContent = 'Delete User';
    btn.onclick = ()=> deleteUserAndMessages(otherId);
    headerControls.appendChild(btn);
  }
}

/* Message element builder */
function messageToElement(m, chatId){
  const wrapper = document.createElement('div');
  wrapper.className = 'message';
  let highlightClass = '';
  if(state.me && m.text && m.text.toLowerCase().includes('@'+state.me.username.toLowerCase())){
    highlightClass = 'mentioned';
  }
  wrapper.innerHTML = `
    <img class="avatar" src="${m.avatar || defaultAvatar(m.fromUsername)}" />
    <div class="body ${highlightClass}">
      <div class="meta">
        <div class="username">${escapeHtml(m.fromUsername)}</div>
        <div class="timestamp">${formatTimestamp(m.ts)}</div>
      </div>
      <div class="text">${formatTextWithLinksAndMentions(m.text)}</div>
      ${m.file ? renderFileEmbedHtml(m.file) : ''}
    </div>
  `;
  if(state.me && state.me.username === ADMIN_USERNAME){
    const del = document.createElement('button');
    del.className = 'admin-delete';
    del.textContent = 'Delete';
    del.style.marginLeft = '8px';
    del.style.height = '32px'; del.style.alignSelf='flex-start';
    del.onclick = async (ev)=>{
      ev.stopPropagation();
      if(confirm('Delete this message?')) {
        const pub = state.messagesCache['public']||[];
        if(pub.find(x=>x.id===m.id)){
          await remove(dbRef(`messages/public/${m.id}`));
        } else {
          const dms = state.messagesCache['dms']||{};
          for(const [dmid, msgs] of Object.entries(dms)){
            if(msgs.find(x=>x.id===m.id)){
              await remove(dbRef(`messages/dms/${dmid}/messages/${m.id}`));
            }
          }
        }
      }
    };
    wrapper.querySelector('.body').prepend(del);
  }
  return wrapper;
}

function renderFileEmbedHtml(file){
  const type = file.type || '';
  const name = escapeHtml(file.name || 'file');
  const data = file.data;
  let html = `<div class="file-embed">`;
  if(type.startsWith('image/')){
    html += `<img src="${data}" style="max-width:540px;border-radius:8px;display:block" /><div><a download="${name}" href="${data}">Download</a></div>`;
  } else if(type.startsWith('video/')){
    html += `<video controls style="max-width:540px;display:block"><source src="${data}" type="${type}">Your browser doesn't support video</video><div><a download="${name}" href="${data}">Download</a></div>`;
  } else if(type.startsWith('audio/')){
    html += `<audio controls><source src="${data}" type="${type}">Your browser doesn't support audio</audio><div><a download="${name}" href="${data}">Download</a></div>`;
  } else {
    html += `<div>${name} <a download="${name}" href="${data}">Download</a></div>`;
  }
  html += `</div>`;
  return html;
}

/* Text formatting: links, mentions, youtube embed */
function escapeHtml(str=''){ return String(str).replace(/[&<>"']/g, (m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

function formatTextWithLinksAndMentions(text=''){
  if(!text) return '';
  let out = escapeHtml(text);
  const ytRegex = /(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([A-Za-z0-9_\-]+))/ig;
  out = out.replace(ytRegex, (m, full, id)=>{
    const iframe = `<div style="margin-top:8px"><iframe width="420" height="236" src="https://www.youtube.com/embed/${id}" frameborder="0" allowfullscreen></iframe></div>`;
    return iframe;
  });
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  out = out.replace(urlRegex, (m)=>`<a href="${m}" target="_blank" style="color:var(--accent)">${escapeHtml(m)}</a>`);
  out = out.replace(/@([a-zA-Z0-9\-_]+)/g, (m, uname)=>`<span class="atlink">@${escapeHtml(uname)}</span>`);
  return out;
}

/* Unread management + title badge */
function updateUnreadBadges(){
  if(state.unread.public && state.unread.public > 0){
    document.title = `[${state.unread.public}] HappeeChat2`;
  } else {
    document.title = `HappeeChat2`;
  }
  renderChatList();
}

function markReadCurrentChat(){
  if(!state._lastSeen) state._lastSeen = {};
  const sel = state.selectedChat;
  if(sel === 'public'){
    state._lastSeen['public'] = (state.messagesCache['public']||[]).length;
    state.unread.public = 0;
  } else {
    state._lastSeen[sel] = (state.messagesCache['dms'] && state.messagesCache['dms'][dmId(state.me.id, sel.split(':')[1])] || []).length;
    state.unread[sel] = 0;
  }
  updateUnreadBadges();
}

/* File attachment handling */
attachBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', async (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  if(f.size > 4*1024*1024){ alert('File exceeds 4MB'); return; }
  const base64 = await fileToBase64(f);
  txtMessage.value += ` [file:${f.name}] `;
  fileInput._pendingFile = { name: f.name, type: f.type, data: base64 };
});

async function fileToBase64(file){
  return new Promise((res, rej)=>{
    const reader = new FileReader();
    reader.onload = ()=> res(reader.result);
    reader.onerror = ()=> rej('err');
    reader.readAsDataURL(file);
  });
}

/* Send handlers */
sendBtn.addEventListener('click', async ()=>{ await handleSend(); });
txtMessage.addEventListener('keydown', async (ev)=>{
  if(ev.key === 'Enter' && !ev.shiftKey){
    ev.preventDefault();
    await handleSend();
  }
});

async function handleSend(){
  const text = txtMessage.value;
  const pendingFile = fileInput._pendingFile || null;
  const to = state.selectedChat;
  const file = pendingFile;
  await sendMessage({ to, text, file });
  txtMessage.value = '';
  fileInput.value = ''; fileInput._pendingFile = null;
  markReadCurrentChat();
}

/* Chat selection / UI */
function selectChat(chatId){
  state.selectedChat = chatId;
  // update title
  if(chatId === 'public') chatTitle.textContent = 'Public Chat';
  else if(chatId.startsWith('dm:')){
    const id = chatId.split(':')[1];
    const u = state.usersCache[id] || { username: 'Unknown' };
    chatTitle.textContent = `DM with ${u.username}`;
    // ensure any previous delete-user button removed (renderHeaderForChat will add if admin)
    const existing = el('#delete-user-btn'); if(existing) existing.remove();
  }
  renderMessagesForCurrentChat();
  markReadCurrentChat();
}

/* Delete user admin */
async function deleteUserAndMessages(userId){
  if(!state.me || state.me.username !== ADMIN_USERNAME) { alert('Admin only'); return; }
  if(state.usersCache[userId] && state.usersCache[userId].username === ADMIN_USERNAME){
    alert('Cannot delete admin user.');
    return;
  }
  if(!confirm('Delete user and all their messages? This is irreversible.')) return;
  await update(dbRef(`users/${userId}`), { deleted: true });
  const pub = state.messagesCache['public'] || [];
  for(const m of pub){
    if(m.fromId === userId) await remove(dbRef(`messages/public/${m.id}`));
  }
  const dms = state.messagesCache['dms'] || {};
  for(const dmid of Object.keys(dms)){
    if(dmid.includes(userId)){
      await remove(dbRef(`messages/dms/${dmid}`));
    } else {
      for(const m of dms[dmid]){
        if(m.fromId === userId){
          await remove(dbRef(`messages/dms/${dmid}/messages/${m.id}`));
        }
      }
    }
  }
  alert('User deleted and messages removed.');
}

/* Auto cleanup */
async function runCleanup(){
  const now = Date.now();
  const pub = state.messagesCache['public'] || [];
  for(const m of pub){
    if(now - (m.ts || 0) > MESSAGE_TTL){
      await remove(dbRef(`messages/public/${m.id}`));
    }
  }
  const dms = state.messagesCache['dms'] || {};
  for(const [dmid, msgs] of Object.entries(dms)){
    for(const m of msgs){
      if(now - (m.ts || 0) > MESSAGE_TTL){
        await remove(dbRef(`messages/dms/${dmid}/messages/${m.id}`));
      }
    }
  }
  const users = state.usersCache || {};
  for(const [id,u] of Object.entries(users)){
    if(u.username === ADMIN_USERNAME) continue;
    if(u.deleted) continue;
    const last = u.lastActive || u.createdAt || 0;
    if(now - last > IDLE_USER_TTL){
      await update(dbRef(`users/${id}`), { deleted: true });
      for(const m of (state.messagesCache['public']||[])){
        if(m.fromId === id) await remove(dbRef(`messages/public/${m.id}`));
      }
      for(const [dmid, msgs2] of Object.entries(state.messagesCache['dms']||{})){
        if(dmid.includes(id)){
          await remove(dbRef(`messages/dms/${dmid}`));
        } else {
          for(const m of msgs2){
            if(m.fromId === id) await remove(dbRef(`messages/dms/${dmid}/messages/${m.id}`));
          }
        }
      }
    }
  }
}

/* Censorship & helpers */
function censorText(s){
  if(!s) return s;
  let out = s;
  for(const w of BLACKLIST){
    const regex = new RegExp(w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),'ig');
    out = out.replace(regex, (m)=> '*'.repeat(m.length));
  }
  return out;
}
function timeAgo(ts){
  const diff = Date.now() - (ts||0);
  if(diff < 60*1000) return 'just now';
  if(diff < 60*60*1000) return Math.floor(diff/60000)+'m';
  if(diff < 24*60*60*1000) return Math.floor(diff/3600000)+'h';
  return Math.floor(diff/86400000)+'d';
}

/* UI interactions */
readMessagesBtn && readMessagesBtn.addEventListener('click', ()=> markReadCurrentChat());
volumeSlider && volumeSlider.addEventListener('input', (e)=>{
  const v = clamp(Number(e.target.value)/100, 0, 1);
  state.pingVolume = v;
});
logoutBtn && logoutBtn.addEventListener('click', ()=>{
  state.me = null;
  openLoginOverlay();
});
el('#btn-new') && (el('#btn-new').onclick = ()=> openLoginOverlay());
el('#btn-settings') && (el('#btn-settings').onclick = ()=> {
  if(!state.me) { alert('Please login.'); openLoginOverlay(); return; }
  alert('Settings placeholder — you are: ' + state.me.username);
});

/* Startup & listeners */
async function afterLogin(){
  state._lastSeen = state._lastSeen || {};
  fetchUsersAndRender();
  listenMessages();
  await update(dbRef(`users/${state.me.id}`), { lastActive: Date.now() });
  selectChat('public');
  setInterval(()=> runCleanup().catch(()=>{}), 1000 * 60 * 10);
  setInterval(()=> { if(state.me) update(dbRef(`users/${state.me.id}`), { lastActive: Date.now() }); }, 1000 * 60 * 2);
}

/* Initial load */
(async function init(){
  openLoginOverlay();
  fetchUsersAndRender();

  // single click handler for accounts is attached when accounts rendered (renderAccountsList)
  // remove duplicated listeners (previous version had both); we keep only the per-div click handler.

  window.addEventListener('beforeunload', ()=>{
    if(state.me) update(dbRef(`users/${state.me.id}`), { lastActive: Date.now() });
  });

})();

/* Utility & debug */
function formatTextForStorage(txt){ return censorText(txt); }
function dataURLtoBlob(dataurl) {
  var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
      bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
  while(n--){
      u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], {type:mime});
}
window.HappeeChat2State = state;

/* Small: update unread when messages node changes (naive) */
onValue(dbRef('messages'), snap=>{
  if(!state.unread.public) state.unread.public = 0;
  updateUnreadBadges();
});

</script>
</body>
</html>
